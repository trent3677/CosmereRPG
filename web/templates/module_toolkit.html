<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeverEndingQuest Developer Toolkit</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
    <style>
        /* === 1. Foundational Styles & Resets === */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Crimson Text', Georgia, serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        /* === 2. Main Layout Container === */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: #2c2c2c;
            border: 2px solid #444;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        /* === 3. Header & Title Styling === */
        .header {
            background-color: #222;
            color: white;
            padding: 25px 30px;
            text-align: center;
            border-bottom: 2px solid #444;
        }

        .header h1 {
            font-family: 'Cinzel', Georgia, serif;
            font-size: 2.8em;
            font-weight: 600;
            color: #FFA500;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.7);
            margin-bottom: 5px;
        }

        .header p {
            font-size: 1.1em;
            color: #aaa;
            font-style: italic;
        }
        
        /* Header Divider Line - Copied from game_interface.html */
        .header-divider-line {
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(255, 165, 0, 0.3) 10%,
                rgba(255, 165, 0, 0.6) 30%,
                #FFA500 50%,
                rgba(255, 165, 0, 0.6) 70%,
                rgba(255, 165, 0, 0.3) 90%,
                transparent 100%
            );
            box-shadow: 0 0 8px rgba(255, 165, 0, 0.4);
            margin-top: 20px;
        }

        /* === 4. Tab Navigation === */
        .tabs {
            display: flex;
            background-color: #333;
            border-bottom: 1px solid #444;
        }

        .tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            background: #333;
            border: none;
            font-size: 1.1em;
            font-weight: bold;
            color: #888;
            transition: all 0.3s;
            border-right: 1px solid #444;
        }
        .tab:last-child { border-right: none; }

        .tab:hover {
            background-color: #3a3a3a;
            color: #e0e0e0;
        }

        .tab.active {
            background-color: #2c2c2c;
            color: #4CAF50;
            border-bottom: 3px solid #4CAF50;
            margin-bottom: -1px;
        }

        /* === 5. Content & Section Styling === */
        .content {
            padding: 30px;
            min-height: 500px;
        }

        .tab-content { display: none; }
        .tab-content.active {
            display: block;
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Status popup styles */
        .status-popup {
            position: fixed;
            bottom: 20px;
            right: 20px;
            min-width: 350px;
            background-color: #2c2c2c;
            border: 2px solid #FFA500;
            border-radius: 8px;
            padding: 20px;
            z-index: 10001;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.6);
            animation: slideInUp 0.3s ease-out;
        }

        .status-popup h4 {
            font-family: 'Cinzel', serif;
            color: #FFA500;
            margin: 0 0 10px 0;
            font-size: 1.2em;
        }

        .status-popup p {
            color: #ccc;
            font-size: 0.9em;
            margin-bottom: 15px;
        }

        .status-popup button {
            padding: 5px 15px;
            background: #444;
            border: 1px solid #666;
            color: #e0e0e0;
            border-radius: 4px;
            cursor: pointer;
            float: right;
        }

        .status-popup.success {
            border-color: #4CAF50;
        }
        .status-popup.success h4 {
            color: #4CAF50;
        }

        .status-popup.error {
            border-color: #f44336;
        }
        .status-popup.error h4 {
            color: #f44336;
        }

        .section {
            margin-bottom: 30px;
            padding: 20px;
            background-color: #1e1e1e;
            border: 1px solid #444;
            border-radius: 6px;
        }

        .section h2 {
            font-family: 'Cinzel', Georgia, serif;
            color: #FFA500;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
            font-size: 1.5em;
        }

        /* === 6. Form Elements & Buttons === */
        .form-group { margin-bottom: 20px; }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #ccc;
            font-size: 1.1em;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 10px 12px;
            background-color: #1a1a1a;
            border: 1px solid #555;
            color: #e0e0e0;
            border-radius: 4px;
            font-family: 'Crimson Text', serif;
            font-size: 1em;
        }
        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.3);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 120px;
        }

        /* === Modern Button Styles with Color-Coded Actions === */
        :root {
            /* Button Action Colors */
            --color-primary: #3b82f6;      /* Bright Blue - for main "Save" actions */
            --color-primary-hover: #2563eb; /* Darker blue for hover */

            --color-secondary: #cccccc;     /* Light Grey - for "Select" and "Save As New" */
            --color-secondary-hover: #ffffff; /* White for hover */
            
            --color-neutral: #555555;       /* Dark Grey - for "Deselect" */
            --color-neutral-hover: #6c6c6c; /* Lighter grey for hover */

            --color-special: #28a745;       /* Green - for "Refresh" */
            --color-special-hover: #218838; /* Darker green for hover */

            --color-destructive: #dc3545;  /* Red - for any future "Delete" buttons */
            --color-destructive-hover: #c82333; /* Darker red for hover */
        }

        /* --- Base Button Style --- */
        .btn {
            padding: 10px 20px;
            border-radius: 6px;
            border: 2px solid transparent;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            text-align: center;
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out, color 0.2s ease-in-out;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* --- Primary Action Button (Blue) --- */
        /* Use for: SAVE (OVERWRITE STYLE), SAVE (Description) */
        .btn.btn-primary {
            background-color: var(--color-primary);
            border-color: var(--color-primary);
            color: white;
        }
        .btn.btn-primary:hover {
            background-color: var(--color-primary-hover);
            border-color: var(--color-primary-hover);
        }

        /* --- Secondary/Ghost Button (White) --- */
        /* Use for: SELECT ALL, SELECT MISSING, SAVE AS NEW */
        .btn.btn-light {
            background-color: transparent;
            color: var(--color-secondary);
            border-color: var(--color-secondary);
        }
        .btn.btn-light:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--color-secondary-hover);
            border-color: var(--color-secondary-hover);
        }

        /* --- Neutral Button (Dark Grey) --- */
        /* Use for: DESELECT ALL */
        .btn.btn-secondary {
            background-color: var(--color-neutral);
            color: #e0e0e0;
            border-color: var(--color-neutral);
        }
        .btn.btn-secondary:hover {
            background-color: var(--color-neutral-hover);
            border-color: var(--color-neutral-hover);
        }

        /* --- Special/Success Button (Green) --- */
        /* Use for: REFRESH */
        .btn.btn-success {
            background-color: var(--color-special);
            color: white;
            border-color: var(--color-special);
        }
        .btn.btn-success:hover {
            background-color: var(--color-special-hover);
            border-color: var(--color-special-hover);
        }

        /* --- Destructive Button (Red) --- */
        .btn.btn-danger {
            background-color: var(--color-destructive);
            color: white;
            border-color: var(--color-destructive);
        }
        .btn.btn-danger:hover {
            background-color: var(--color-destructive-hover);
            border-color: var(--color-destructive-hover);
        }
        
        /* --- Warning Button (Amber/Yellow) --- */
        /* Use for: Add to Bestiary */
        .btn.btn-warning {
            background-color: #ffc107;
            border-color: #ffc107;
            color: #1a1a1a; /* Dark text for better contrast */
        }
        .btn.btn-warning:hover {
            background-color: #e0a800;
            border-color: #e0a800;
        }

        .btn:disabled { 
            opacity: 0.5; 
            cursor: not-allowed; 
        }

        /* === 7. Pack Table Layout === */
        .pack-list-container {
            border: 1px solid #444;
            border-radius: 6px;
            background-color: #2c2c2c;
            overflow: hidden; /* This keeps the rounded corners nice */
        }

        .pack-list-header, .pack-list-row {
            display: grid;
            /* Defines our 5 columns: Active, Name, Details, Stats, Actions */
            grid-template-columns: 60px 1.5fr 2.5fr 180px 240px; /* Adjusted column widths */
            align-items: center;
            gap: 20px;
            padding: 12px 20px;
        }

        .pack-list-header {
            font-family: 'Cinzel', serif;
            color: #aaa;
            text-transform: uppercase;
            font-size: 0.8em;
            background-color: #1e1e1e;
            border-bottom: 2px solid #444;
        }

        .pack-list-body {
            display: flex;
            flex-direction: column;
        }

        .pack-list-row {
            border-bottom: 1px solid #3a3a3a;
            transition: background-color 0.2s;
        }

        .pack-list-row:last-child {
            border-bottom: none; /* No border on the last item */
        }

        .pack-list-row:hover {
            background-color: #333;
        }

        .pack-list-cell {
            display: flex;
            align-items: center; /* Vertically center content in the cell */
        }

        /* Center-align specific header titles */
        .pack-list-header .pack-list-cell:nth-child(1),
        .pack-list-header .pack-list-cell:nth-child(4) {
            justify-content: center;
        }
        .pack-list-header .pack-list-cell:last-child {
            justify-content: flex-end;
        }

        /* Custom styling for the active status indicator */
        .pack-status-indicator {
            width: 22px;
            height: 22px;
            border: 2px solid #555;
            border-radius: 50%;
            margin: 0 auto;
            transition: all 0.3s ease;
            transform: scale(0.8); /* Make inactive ones slightly smaller */
            background-color: transparent;
        }

        .pack-status-indicator.active {
            border-color: #4CAF50;
            background-color: #4CAF50;
            transform: scale(1);
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.7);
        }

        .pack-name-cell {
            font-family: 'Cinzel', serif;
            font-size: 1.1em; /* Reduced from 1.3em */
            font-weight: 600;
            color: #e0e0e0;
        }

        .pack-meta-cell {
            font-size: 0.9em; /* Increased from 0.8em */
            color: #999;
            font-style: italic;
            white-space: nowrap; /* Prevents text from wrapping */
        }

        .pack-stats-cell {
            justify-content: center;
            gap: 30px;
        }

        .pack-stats-cell .stat {
            text-align: center;
        }

        .pack-stats-cell .stat-value {
            font-family: 'Cinzel', serif;
            font-size: 1.3em; /* Reduced from 1.5em */
            font-weight: 600;
            color: #e0e0e0;
        }

        .pack-stats-cell .stat-label {
            font-size: 0.7em;
            color: #888;
            text-transform: uppercase;
        }

        .pack-actions-cell {
            justify-content: flex-end;
            gap: 10px;
        }

        /* Icon button styles */
        .btn-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 40px;  /* Square button */
            height: 40px; /* Square button */
            padding: 0;   /* Remove padding */
            border-radius: 6px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }

        .btn-icon svg {
            width: 20px;
            height: 20px;
            fill: white;
        }

        .btn-icon:hover {
            transform: scale(1.1);
        }

        /* Specific colors for icon buttons */
        .btn-icon.btn-success { background-color: var(--color-special); }
        .btn-icon.btn-success:hover { background-color: var(--color-special-hover); }

        .btn-icon.btn-primary { background-color: var(--color-primary); }
        .btn-icon.btn-primary:hover { background-color: var(--color-primary-hover); }

        .btn-icon.btn-secondary { background-color: var(--color-neutral); }
        .btn-icon.btn-secondary:hover { background-color: var(--color-neutral-hover); }

        .btn-icon.btn-danger { background-color: var(--color-destructive); }
        .btn-icon.btn-danger:hover { background-color: var(--color-destructive-hover); }

        .btn-icon:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        .monster-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: #1a1a1a;
        }

        .monster-item {
            display: flex;
            align-items: center;
            padding: 10px;
            background: #2c2c2c;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s;
            border: 1px solid #3a3a3a;
        }
        .monster-item:hover { background: #3a3a3a; }
        .monster-item input[type="checkbox"] { margin-right: 10px; width: 18px; height: 18px; }

        /* === 8. Progress Bars & Logs === */
        .progress-container {
            display: none;
            margin-top: 20px;
            padding: 20px;
            background: #1e1e1e;
            border-radius: 6px;
        }
        .progress-container.active { display: block; }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #81C784);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .progress-status { text-align: center; color: #ccc; margin-top: 10px; font-style: italic; }

        .log-container {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        .log-entry { margin-bottom: 5px; padding: 5px; }
        .log-entry.success { color: #4CAF50; }
        .log-entry.error { color: #f44336; }
        .log-entry.info { color: #2196F3; }

        /* Updated rule for the create pack form in two-column layout */
        .create-pack-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* === 9. Import Pack Section === */
        .import-container {
            background-color: #1a1a1a;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 15px;
        }

        .import-control-row {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .file-display {
            flex-grow: 1;
            padding: 10px 12px;
            background-color: #2c2c2c;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            color: #aaa;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .import-preview {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #444;
        }

        .import-preview h4 {
            font-family: 'Cinzel', serif;
            color: #FFA500;
            margin-bottom: 10px;
        }

        #preview-metadata {
            background: #2c2c2c;
            padding: 15px;
            border-radius: 4px;
            font-size: 0.9em;
            line-height: 1.6;
            color: #ccc;
        }

        #preview-metadata strong {
            color: #e0e0e0;
        }

        .import-confirmation {
            margin-top: 15px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end; /* CHANGED from 'center' */
            gap: 15px; /* ADDED for spacing */
        }

        .import-confirmation p {
            color: #999;
            font-style: italic;
            font-size: 0.9em;
        }

        .import-confirmation code {
            background: #1a1a1a;
            padding: 2px 5px;
            border-radius: 3px;
            color: #4CAF50;
        }

        .import-folder-input {
            width: 100%;
            padding: 8px 10px;
            background-color: #1a1a1a;
            border: 1px solid #555;
            color: #4CAF50;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .file-list { margin-top: 20px; }
        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #1e1e1e;
            border-radius: 5px;
            margin-bottom: 10px;
            border: 1px solid #444;
        }
        .file-item input.monster-id {
            background-color: #1a1a1a;
            border: 1px solid #555;
            color: #e0e0e0;
            border-radius: 3px;
            padding: 5px;
            margin-left: 15px;
        }

        /* === 11. Status Indicator === */
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 10px;
            vertical-align: middle;
        }
        .status-indicator.online {
            background: #4CAF50;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(76, 175, 80, 0); }
            100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); }
        }
        
        /* === 12. Scrollbar Styling === */
        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: #1a1a1a; }
        ::-webkit-scrollbar-thumb { background: #555; border-radius: 5px; }
        ::-webkit-scrollbar-thumb:hover { background: #666; }

        /* === 13. NEW LAYOUT STYLES === */
        .two-column-layout {
            display: grid;
            grid-template-columns: 1fr 1fr; /* Balanced 50/50 split */
            gap: 30px;
            align-items: start;
        }

        .two-column-layout.balanced {
            grid-template-columns: 1fr 1fr; /* 50% / 50% split */
        }

        /* === NEW CSS for Monster Generator Refactor === */

        .generator-controls {
            display: flex;
            justify-content: space-between;
            align-items: flex-end; /* Aligns items to the bottom */
            gap: 30px;
            margin-bottom: 20px;
        }

        .generator-options {
            display: flex;
            gap: 20px;
            flex-grow: 1; /* Allows this section to take up available space */
        }

        .generator-options .form-group {
            flex: 1; /* Each dropdown group takes equal space */
            margin-bottom: 0;
        }

        .monster-selection-controls {
            text-align: right;
            margin-bottom: 0;
        }

        .monster-selection-controls label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #ccc;
            font-size: 1.1em;
        }

        .monster-selection-controls .monster-buttons {
            display: flex;
            gap: 10px;
        }
        
        /* === REFINED Generator Preview Section Styles === */
        
        /* Remove background/border from the main container, making it just a layout wrapper */
        .prompt-description-section {
            background: none;
            border: none;
            padding: 0;
            margin: 25px 0;
        }
        
        .preview-layout {
            display: grid;
            grid-template-columns: 1fr auto 1.5fr; /* Gives the right column 50% more space than the left */
            gap: 20px;
            align-items: stretch; /* CHANGED from 'center' */
        }
        
        /* The main container for each editor, replacing .preview-box */
        .prompt-editor {
            display: flex;
            flex-direction: column;
        }
        
        .prompt-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .prompt-editor-header h4 {
            font-family: 'Cinzel', serif;
            color: #FFA500;
            font-size: 1.1em;
            font-weight: 600;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .preview-textarea {
            width: 100%;
            flex-grow: 1;
            min-height: 80px; /* Drastically reduced height */
            background-color: transparent; /* Make it see-through */
            border: 1px solid #FFA500; /* Thin orange border */
            border-radius: 4px;
            padding: 10px;
            color: #ccc;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            resize: vertical;
            transition: background-color 0.2s;
        }
        
        .preview-textarea:focus {
            outline: none;
            background-color: rgba(255, 165, 0, 0.05); /* Subtle glow on focus */
            box-shadow: 0 0 5px rgba(255, 165, 0, 0.3);
        }
        
        .btn-small {
            padding: 5px 15px;
            font-size: 0.8em;
        }
        
        .save-as-new {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }
        
        .save-as-new input {
            flex-grow: 1;
            padding: 6px 10px;
            font-size: 0.9em;
            background-color: #1a1a1a;
            border: 1px solid #555;
            color: #ccc;
        }
        
        .selected-monster-info {
            margin-top: 8px;
            font-style: italic;
            color: #888;
            font-size: 0.9em;
            text-align: right;
        }
        
        /* --- NEW CSS for Final Generator Refinements --- */
        
        .preview-separator {
            font-family: 'Cinzel', serif;
            font-size: 2.5em;
            color: #FFA500;
            text-shadow: 0 0 10px rgba(255, 165, 0, 0.5);
        }
        
        .monster-list-container {
            margin-top: 25px;
        }
        
        .monster-list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        
        .monster-list-header h4 {
            font-family: 'Cinzel', serif;
            color: #FFA500;
            font-size: 1.2em;
            font-weight: 600;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .monster-list-header .monster-buttons {
            display: flex;
            gap: 10px;
        }
        
        /* === Pack Activation Confirmation Modal === */
        .modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .pack-confirm-content {
            background-color: #2c2c2c;
            padding: 30px;
            border-radius: 10px;
            border: 2px solid #FFA500;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
        }

        .pack-confirm-content h3 {
            font-family: 'Cinzel', serif;
            color: #FFA500;
            margin-bottom: 20px;
            text-align: center;
        }

        .modal-warning {
            background-color: #1a1a1a;
            border: 1px solid #f44336;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .modal-warning p {
            color: #e0e0e0;
            margin: 10px 0;
        }

        .backup-name {
            font-family: 'Courier New', monospace;
            color: #4CAF50;
            background-color: #222;
            padding: 5px 10px;
            border-radius: 3px;
            display: inline-block;
        }

        .modal-pack-info {
            background-color: #1a1a1a;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .modal-pack-info p {
            color: #aaa;
            margin: 5px 0;
        }

        .modal-pack-info strong {
            color: #FFA500;
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        /* === Enhanced CSS for Generator Preview & Monster List === */
        
        .section-subtitle {
            font-family: 'Cinzel', serif;
            color: #FFA500;
            margin-bottom: 15px;
            font-size: 1.2em;
            font-weight: 600;
        }
        
        /* Monster Item with Thumbnails */
        .monster-item {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 5px 10px; /* Tighter padding */
            transition: background 0.2s;
            border-left: 4px solid transparent; /* Increased from 3px for visibility */
            border-right: 4px solid transparent; /* Added for right-side highlighting */
        }
        
        /* Color coding for monster sources */
        .monster-item.monster-bestiary {
            border-left-color: #4CAF50; /* Green for bestiary monsters */
        }
        
        .monster-item.monster-pack-only {
            border-left-color: #FFC107; /* Yellow/amber for pack-only monsters */
        }
        
        /* ADD this new rule for the red highlight */
        .monster-item.monster-bestiary-only {
            border-left-color: #f44336; /* Red for missing monsters */
        }
        
        .monster-item:hover {
            background: rgba(255, 165, 0, 0.05);
        }
        
        /* ADD these new rules for the legend */
        .monster-list-legend {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            font-size: 0.85em;
            color: #aaa;
            padding-left: 5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0; /* Using explicit margins instead of gap */
        }

        .legend-color-box {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            margin-right: 8px; /* Space between color box and text */
        }

        .legend-color-box.bestiary {
            background-color: #4CAF50;
        }

        .legend-color-box.pack-only {
            background-color: #FFC107;
        }

        /* ADD this new rule for the red legend box */
        .legend-color-box.missing-from-pack {
            background-color: #f44336;
        }

        /* Blue highlight for monsters in selected module */
        .monster-item.monster-in-module {
            border-right-color: #2196F3; /* Blue for module monsters - moved to right side */
        }

        .legend-color-box.in-module {
            background-color: #2196F3;
        }
        
        /* Checkbox styling for legend filters */
        .legend-item input[type="checkbox"] {
            margin-right: 4px;      /* Tighter spacing */
            vertical-align: middle;
            width: 14px;            /* Smaller checkbox */
            height: 14px;           /* Smaller checkbox */
            flex-shrink: 0;         /* Prevent checkbox from shrinking on smaller screens */
        }
        
        .legend-item label {
            cursor: pointer;
            display: flex;
            align-items: center;
        }

        /* Shared style for all top option boxes for consistent padding/radius */
        .option-box {
            border-radius: 6px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.1);
        }

        /* The specific outline colors */
        .orange-outline {
            border: 2px solid #FFA500; /* Orange */
        }
        
        .blue-outline {
            border: 2px solid #2196F3; /* Blue */
        }

        .purple-outline {
            border: 2px solid #9c27b0; /* Purple */
        }

        /* Blue outline for module selector */
        .module-cross-reference-box {
            border: 2px solid #2196F3; /* Blue border */
            background-color: rgba(33, 150, 243, 0.05); /* Faint blue background */
        }
        
        .monster-label {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-grow: 1;
            cursor: pointer;
        }
        
        .monster-label input[type="checkbox"] {
            margin-right: 10px;
        }
        
        .monster-label span {
            color: #fff;
        }
        
        /* Monster thumbnail preview */
        .monster-thumbnail-preview {
            width: 40px;
            height: 40px;
            background-color: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            flex-shrink: 0;
            margin-left: 15px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .monster-thumbnail-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .no-image-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            background: rgba(244, 67, 54, 0.1);
            border: 1px solid rgba(244, 67, 54, 0.3);
            border-radius: 4px;
        }
        
        .monster-thumbnail-preview .no-image-placeholder {
            font-size: 20px;
            color: #444;
        }
        
        /* Enhanced preview textarea styling */
        .preview-textarea {
            min-height: 80px;
            max-height: 300px;
            flex-grow: 1; /* Ensure vertical alignment */
        }
        
        .preview-textarea:focus {
            background: #222;
        }
        
        /* Make the Generation Preview section more prominent */
        .prompt-description-section h3 {
            text-align: center;
            padding-bottom: 15px;
            border-bottom: 2px solid #444;
            margin-bottom: 20px;
        }

        .model-warning {
            display: none; /* Hidden by default */
            font-size: 0.8em;
            color: #aaa;
            font-style: italic;
            margin-top: 5px;
        }

        .settings-form-container {
            max-width: 800px;
            margin: 0 auto;
        }
        
        /* Export Notification Styles */
        .export-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10000;
            background: #2c2c2c;
            border: 2px solid #444;
            border-radius: 10px;
            padding: 25px;
            min-width: 400px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        .notification-content h4 {
            color: #FFA500;
            font-family: 'Cinzel', Georgia, serif;
            margin-bottom: 10px;
            font-size: 1.3em;
        }
        
        .notification-content.success h4 {
            color: #4CAF50;
        }
        
        .notification-content p {
            color: #e0e0e0;
            line-height: 1.5;
            margin-bottom: 15px;
        }
        
        .notification-content button {
            background: linear-gradient(145deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .notification-content button:hover {
            background: linear-gradient(145deg, #45a049, #4CAF50);
            transform: translateY(-1px);
        }

        /* === Media Popup and Video Indicators === */
        
        /* Thumbnail Enhancements */
        .monster-thumbnail-preview {
            position: relative; /* Needed for the icon overlay */
            cursor: pointer; /* Indicates it's clickable */
        }
        
        .video-indicator {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 16px;
            height: 16px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none; /* Allows clicks to pass through to the parent */
        }
        
        .video-indicator svg {
            width: 10px;
            height: 10px;
            fill: white;
        }
        
        /* Media Popup Modal Styles */
        #media-modal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8); /* Black overlay */
            align-items: center;
            justify-content: center;
        }
        
        #media-modal.active {
            display: flex; /* Show when active */
        }
        
        .media-modal-content {
            background-color: #2c2c2c;
            border: 2px solid #555;
            border-radius: 8px;
            padding: 0; /* Remove padding to let media touch edges */
            max-width: 80vw;
            max-height: 80vh;
            width: auto;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .media-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background-color: #1e1e1e;
            border-bottom: 1px solid #444;
        }
        
        .media-modal-header h3 {
            font-family: 'Cinzel', serif;
            color: #FFA500;
            margin: 0;
        }
        
        .media-modal-close {
            color: #888;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }
        
        .media-modal-close:hover {
            color: white;
        }
        
        .media-modal-body {
            padding: 5px;
            background-color: #1a1a1a;
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .media-modal-body img,
        .media-modal-body video {
            max-width: 100%;
            max-height: 70vh; /* Ensure media fits within viewport */
            display: block;
            border-radius: 4px;
        }

        /* === 14. Module Builder Styles === */
        #main-container {
            display: flex;
            flex: 1;
            gap: 10px;
            height: calc(100% + 60px);
            margin: -30px;
        }

        .panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            border: 1px solid #444;
            background-color: #1e1e1e;
            border-radius: 0;
            overflow: hidden;
        }

        .builder-panel {
            flex: 2;
        }

        .modules-panel {
            flex: 1;
            max-width: 400px;
            background-color: #2c2c2c;
        }
        
        .panel-header {
            color: #FFA500;
            font-family: 'Cinzel', serif;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 1.1em;
            background-color: #222;
            border-bottom: 1px solid #444;
            padding: 10px 15px;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .intro-text {
            color: #aaa;
            font-style: italic;
            margin-bottom: 30px;
            line-height: 1.6;
        }
        
        .game-input {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            background-color: #1a1a1a;
            border: 1px solid #555;
            color: #e0e0e0;
            font-family: 'Crimson Text', serif;
            font-size: 1em;
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        
        .game-input:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 5px rgba(76, 175, 80, 0.3);
        }
        
        textarea.game-input {
            resize: vertical;
            min-height: 150px;
        }
        
        .game-button {
            padding: 12px 24px;
            background-color: #333;
            border: 1px solid #4CAF50;
            color: #4CAF50;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            border-radius: 5px;
            text-transform: uppercase;
        }
        
        .game-button.primary {
            background: linear-gradient(145deg, #4CAF50, #2E8B57);
            color: white;
        }
        
        .game-button.primary:hover:not(:disabled) {
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
        }
        
        .game-button:hover:not(:disabled) {
            background-color: #4CAF50;
            color: white;
        }
        
        .game-button.cancel {
            background: linear-gradient(145deg, #6c757d, #495057);
            border-color: #6c757d;
            color: white;
            margin-top: 10px;
        }
        
        #generation-progress {
            margin-top: 30px;
            animation: fadeIn 0.5s ease;
        }
        
        #progress-stages {
            list-style: none;
            padding: 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        
        #progress-stages li {
            padding: 8px;
            background-color: #2a2a2a;
            border: 1px solid #555;
            color: #777;
            text-align: center;
            font-size: 0.8em;
            border-radius: 4px;
            transition: all 0.3s ease;
            position: relative;
        }
        
        #progress-stages li.stage-active {
            color: #FFA500;
            font-weight: bold;
            border-color: #FFA500;
            background-color: rgba(255, 165, 0, 0.1);
            animation: pulse 1.5s infinite;
        }
        
        #progress-stages li.stage-complete {
            color: #4CAF50;
            border-color: #4CAF50;
            background-color: rgba(76, 175, 80, 0.05);
        }
        
        #progress-bar-container {
            width: 100%;
            height: 25px;
            background-color: #2a2a2a;
            border: 1px solid #444;
            border-radius: 15px;
            margin-bottom: 15px;
            position: relative;
        }
        
        #progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50 0%, #6faa5a 100%);
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 15px;
        }
        
        #progress-percentage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Share Tech Mono', monospace;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.7);
        }
        
        #status-message {
            text-align: center;
            font-size: 1em;
            color: #ccc;
            margin-top: 15px;
            min-height: 20px;
            font-style: italic;
        }
        
        #results-section {
            animation: fadeIn 0.5s ease;
        }
        
        #module-output {
            background-color: #1a1a1a;
            border: 1px solid #4CAF50;
            padding: 15px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.9em;
            color: #4CAF50;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 15px;
        }
        
        .error-message {
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px solid #ff4444;
            color: #ff6666;
            padding: 15px;
            margin-top: 20px;
        }
        
        .module-item {
            background-color: #1e1e1e;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .module-item:hover {
            border-color: #FFA500;
        }
        
        .module-name {
            color: #4CAF50;
            font-family: 'Cinzel', serif;
            font-weight: bold;
            font-size: 1.2em;
            margin-bottom: 5px;
        }

        .module-level {
            color: #FFA500;
            font-weight: bold;
            font-size: 1em;
            margin-bottom: 10px;
        }

        .module-details {
            border-top: 1px solid #444;
            padding-top: 10px;
            font-size: 0.9em;
        }

        .module-detail-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            color: #aaa;
        }

        .module-detail-item span:last-child {
            color: #e0e0e0;
            font-weight: bold;
        }

        .no-modules {
            text-align: center;
            color: #888;
            font-style: italic;
            padding: 20px;
        }
        
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #FFA500;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
            vertical-align: middle;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* === 15. Tooltip Styles === */
        .tooltip-trigger {
            display: inline-block;
            width: 20px;
            height: 20px;
            background-color: #444;
            color: #aaa;
            border: 1px solid #666;
            border-radius: 50%;
            text-align: center;
            line-height: 18px;
            font-size: 14px;
            font-weight: bold;
            cursor: help;
            margin-left: 10px;
            position: relative; /* Needed for tooltip positioning */
            vertical-align: middle;
        }

        .tooltip-trigger:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 125%; /* Position above the icon */
            left: 50%;
            transform: translateX(-50%);
            background-color: #1a1a1a;
            color: #FFA500; /* Orange text */
            padding: 10px 15px;
            border: 1px solid #FFA500;
            border-radius: 6px;
            font-size: 0.9em;
            font-family: 'Crimson Text', serif;
            font-weight: normal;
            white-space: pre-wrap; /* Allows line breaks */
            width: 280px; /* Set a consistent width */
            z-index: 10001; /* Ensure it's on top */
            text-align: left;
            pointer-events: none; /* Allow hover to pass through */
            opacity: 1;
            visibility: visible;
            transition: opacity 0.2s;
        }

        .tooltip-trigger::after {
            content: '';
            position: absolute;
            opacity: 0;
            visibility: hidden;
        }

        /* Add flex display to headers to align the icon correctly */
        .section h2, .panel-header, .prompt-editor-header {
            display: flex;
            align-items: center;
        }
        
        /* === 16. NPC Tab Styles === */
        /* Legend for the NPC list */
        .npc-list-legend {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            font-size: 0.85em;
            color: #aaa;
            padding-left: 5px;
        }

        /* NPC item styles in the grid */
        .npc-item {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 5px 10px;
            transition: background 0.2s;
            border-left: 4px solid transparent;
        }

        .npc-item.has-portrait {
            border-left-color: #4CAF50; /* Green */
        }

        .npc-item.missing-portrait {
            border-left-color: #f44336; /* Red */
        }
        
        .npc-item.is-local {
            border-right: 4px solid #00BCD4; /* Cyan right-side border */
        }

        .npc-item:hover {
            background: rgba(255, 165, 0, 0.05);
        }

        .npc-thumbnail-preview {
            width: 40px;
            height: 40px;
            background-color: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            flex-shrink: 0;
            margin-left: 15px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .npc-thumbnail-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .npc-thumbnail-preview .no-image-placeholder {
            color: #666;
            font-size: 20px;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>NeverEndingQuest Developer Toolkit</h1>
            <p>The Dungeon Master's Workbench for creating and managing game assets.</p>
            <div class="header-divider-line"></div>
        </div>
        
        <div class="tabs">
            <button class="tab active" onclick="switchTab('packs')">Graphic Pack Management</button>
            <button class="tab" onclick="switchTab('generator')">Monster Management & Generator</button>
            <button class="tab" onclick="switchTab('npcs')">NPC Management & Generator</button>
            <button class="tab" onclick="switchTab('videos')">Video Processor</button>
            <button class="tab" onclick="switchTab('builder')">Module Builder</button>
        </div>
        
        <div class="content">
            <!-- Graphic Pack Management Tab - SINGLE COLUMN LAYOUT -->
            <div id="packs-tab" class="tab-content active">
                <!-- NEW TWO-COLUMN LAYOUT -->
                <div class="two-column-layout" style="margin-bottom: 30px;">
                    <!-- Column 1: Import Pack -->
                    <div class="section">
                        <h2>Import Graphic Pack<span class="tooltip-trigger" data-tooltip="Import a graphic pack from a .zip file. Choose which assets to import to your game.">?</span></h2>
                        <div class="import-container">
                            <div class="import-control-row">
                                <div id="file-path-display" class="file-display">No file selected...</div>
                                <button class="btn btn-secondary" onclick="document.getElementById('importFile').click()">Select File</button>
                                <input type="file" id="importFile" accept=".zip" style="display:none" onchange="handleFileSelection(this.files)">
                            </div>
                            <div id="import-preview-area" class="import-preview" style="display: none;">
                                <h4>Pack Contents<span class="tooltip-trigger" data-tooltip="Shows what assets are available in this pack.">?</span></h4>
                                <div id="preview-metadata"></div>
                                
                                <div class="import-options" style="margin: 15px 0; padding: 15px; background: #1a1a1a; border-radius: 5px;">
                                    <h4 style="margin-bottom: 10px; color: #FFA500;">Select Assets to Import:</h4>
                                    <label class="checkbox-label" style="display: block; margin: 8px 0;">
                                        <input type="checkbox" id="import-monsters" checked style="margin-right: 8px;">
                                        <span id="monsters-count-label">Import Monsters</span>
                                    </label>
                                    <label class="checkbox-label" style="display: block; margin: 8px 0;">
                                        <input type="checkbox" id="import-npcs" checked style="margin-right: 8px;">
                                        <span id="npcs-count-label">Import NPCs</span>
                                    </label>
                                </div>
                                
                                <div class="import-confirmation">
                                    <div class="form-group" style="flex-grow: 1; margin-bottom: 0;">
                                        <label for="target-folder-name" style="font-size: 0.9em; color: #999;">Destination Folder:</label>
                                        <input type="text" id="target-folder-name" class="import-folder-input">
                                    </div>
                                    <button id="confirm-import-btn" class="btn btn-primary" onclick="confirmImport()">Confirm Import</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Column 2: Create New Pack -->
                    <div class="section">
                        <h2>Create New Pack<span class="tooltip-trigger" data-tooltip="Create a new, empty graphic pack. You can then use the 'Monster Management' tab to generate images into this new pack.">?</span></h2>
                        <div class="form-group">
                            <label for="new-pack-name">Pack Name (Internal ID)<span class="tooltip-trigger" data-tooltip="The internal identifier for the pack. Must be lowercase with no spaces (e.g., 'my_custom_pack').">?</span></label>
                            <input type="text" id="new-pack-name" placeholder="e.g., anime_style_pack">
                        </div>
                        <div class="form-group">
                            <label for="new-pack-display-name">Display Name<span class="tooltip-trigger" data-tooltip="The human-readable name shown in the UI. Can include spaces and capitalization.">?</span></label>
                            <input type="text" id="new-pack-display-name" placeholder="e.g., Anime Style Pack">
                        </div>
                        <div class="form-group">
                            <label for="new-pack-author">Author<span class="tooltip-trigger" data-tooltip="Your name or alias, credited as the pack creator.">?</span></label>
                            <input type="text" id="new-pack-author" placeholder="Your name or alias">
                        </div>
                        <button class="btn btn-primary" onclick="createNewPack()">Create Pack</button>
                    </div>
                </div>

                <div class="section">
                    <h2>Available Asset Packs<span class="tooltip-trigger" data-tooltip="Manage all installed graphic packs. The 'Active' pack is used by the game. 'Merge' copies assets from an inactive pack into the active one, overwriting any duplicates.">?</span></h2>
                    <div class="pack-list-container">
                        <!-- The Header for our table will go here -->
                        <div class="pack-list-header">
                            <div class="pack-list-cell">Active</div>
                            <div class="pack-list-cell">Pack Name</div>
                            <div class="pack-list-cell">Details</div>
                            <div class="pack-list-cell">Stats</div>
                            <div class="pack-list-cell">Actions</div>
                        </div>
                        <!-- The list of packs will be dynamically inserted here -->
                        <div class="pack-list-body" id="packGrid">
                            <!-- Packs will be loaded here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Monster Management & Generator Tab - UPDATED LAYOUT -->
            <div id="generator-tab" class="tab-content">
                <div class="section">
                    <h2>Generate Monster Images<span class="tooltip-trigger" data-tooltip="This is the main workspace for creating monster art. Select a pack, style, and monsters, then generate images.">?</span></h2>
                    <!-- REPLACE the old .form-column-layout with this new .generator-controls block -->
                    <div class="generator-controls">
                        <!-- Part 1: All the dropdown options -->
                        <div class="generator-options">
                            <div class="form-group option-box orange-outline">
                                <label for="genPack">Target Pack:<span class="tooltip-trigger" data-tooltip="The graphic pack where newly generated images will be saved.">?</span></label>
                                <select id="genPack" onchange="loadMonsters(); refreshMonsterThumbnails();">
                                    <option value="__new__">+ Create New Pack...</option>
                                </select>
                            </div>
                            <div class="form-group option-box orange-outline">
                                <label for="genStyle">Style Template:<span class="tooltip-trigger" data-tooltip="The artistic style used for image generation. You can edit existing prompts or save new custom styles.">?</span></label>
                                <select id="genStyle" onchange="loadStylePrompt()">
                                    <!-- Styles will be loaded from JSON -->
                                </select>
                            </div>
                            <div class="form-group option-box purple-outline">
                                <label for="genModel">AI Model:<span class="tooltip-trigger" data-tooltip="The underlying AI model for image generation. DALL-E 3 is the default.">?</span></label>
                                <select id="genModel" onchange="checkModelWarning()">
                                    <option value="dall-e-3">DALL-E 3 (Default)</option>
                                    <option value="gpt-image-1">GPT-Image (Best Quality)</option>
                                </select>
                                <div class="model-warning" id="modelWarning">
                                    Warning: GPT-Image requires a validated OpenAI account with higher tier access.
                                </div>
                            </div>
                            <div class="form-group module-cross-reference-box option-box">
                                <label for="genModule">Module Cross-Reference:<span class="tooltip-trigger" data-tooltip="Select an adventure module to see which monsters it uses. This helps identify which assets you need to create.">?</span></label>
                                <div style="display: flex; gap: 10px;">
                                    <select id="genModule" onchange="crossReferenceModuleMonsters()" style="flex-grow: 1;">
                                        <option value="">-- Select a Module --</option>
                                        <!-- Modules will be loaded here by JavaScript -->
                                    </select>
                                    <button class="btn btn-secondary btn-small" onclick="clearModuleCrossReference()" title="Clear module filter">Clear</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Prompt and Description Preview Section -->
                    <div class="prompt-description-section">
                        <div class="preview-layout">
                            <!-- Style Prompt Editor -->
                            <div class="prompt-editor">
                                <div class="prompt-editor-header">
                                    <h4>Style Prompt<span class="tooltip-trigger" data-tooltip="The text prompt that defines the artistic style. Edit this to fine-tune the look of your images.">?</span></h4>
                                    <button class="btn btn-small btn-primary" onclick="saveStylePrompt()">Save (Overwrite Style)</button>
                                </div>
                                <textarea id="stylePromptBox" class="preview-textarea" placeholder="Select a style template to see its prompt..."></textarea>
                                <div class="save-as-new">
                                    <input type="text" id="newStyleName" placeholder="Save as new style name...">
                                    <button class="btn btn-light btn-small" onclick="saveAsNewStyle()">Save as New</button>
                                </div>
                            </div>
                            
                            <!-- INSERT THIS NEW ELEMENT -->
                            <div class="preview-separator">+</div>
                            
                            <!-- Monster Description Editor -->
                            <div class="prompt-editor">
                                <div class="prompt-editor-header">
                                    <h4>Monster Description<span class="tooltip-trigger" data-tooltip="The descriptive text used by the AI to visualize the monster. Select a monster from the list below to view and edit its description.">?</span></h4>
                                    <button class="btn btn-small btn-primary" onclick="saveMonsterDescription()">Save</button>
                                </div>
                                <textarea id="monsterDescriptionBox" class="preview-textarea" placeholder="Select a monster from the list below..."></textarea>
                                <div class="selected-monster-info">
                                    <small id="selectedMonsterName">No monster selected</small>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- ADD THIS NEW WRAPPER AND PASTE THE CONTROLS HERE -->
                    <div class="monster-list-container">
                        <div class="monster-list-header">
                            <h4>Available Monsters in Pack<span class="tooltip-trigger" data-tooltip="This list shows all monsters from the bestiary and the selected pack. Use the legend checkboxes above to filter the list.">?</span></h4>
                            <div class="monster-buttons">
                                <button class="btn btn-light btn-small" onclick="selectAllMonsters()">Select All</button>
                                <button class="btn btn-light btn-small" onclick="selectMissingImages()">Select Missing</button>
                                <button class="btn btn-secondary btn-small" onclick="deselectAllMonsters()">Deselect All</button>
                            </div>
                        </div>
                        
                        <!-- Interactive legend with filter checkboxes -->
                        <div class="monster-list-legend">
                            <div class="legend-item" title="Monster exists in the Bestiary and the selected Graphic Pack.">
                                <input type="checkbox" id="filter-bestiary" class="legend-filter" onchange="applyLegendFilters()">
                                <label for="filter-bestiary">
                                    <span class="legend-color-box bestiary"></span> In Bestiary <span id="count-bestiary">(0)</span>
                                </label>
                            </div>
                            <div class="legend-item" title="Monster exists in the selected Graphic Pack but not in the local Bestiary.">
                                <input type="checkbox" id="filter-pack-only" class="legend-filter" onchange="applyLegendFilters()">
                                <label for="filter-pack-only">
                                    <span class="legend-color-box pack-only"></span> Pack Exclusive <span id="count-pack-only">(0)</span>
                                </label>
                            </div>
                            <div class="legend-item" title="Monster exists in the Bestiary but is MISSING from the selected Graphic Pack.">
                                <input type="checkbox" id="filter-missing" class="legend-filter" onchange="applyLegendFilters()">
                                <label for="filter-missing">
                                    <span class="legend-color-box missing-from-pack"></span> Missing from Pack <span id="count-missing">(0)</span>
                                </label>
                            </div>
                            <div class="legend-item" title="Monster is used in the selected Module. The blue highlight appears on the right side of the tile.">
                                <input type="checkbox" id="filter-in-module" class="legend-filter" onchange="applyLegendFilters()">
                                <label for="filter-in-module">
                                    <span class="legend-color-box in-module"></span> In Selected Module <span id="count-in-module">(0)</span>
                                </label>
                            </div>
                            <!-- Special mode for missing bestiary entries -->
                            <div class="legend-item" title="Show only monsters from the selected module that are missing from the Bestiary.">
                                <input type="checkbox" id="filter-missing-bestiary" onchange="toggleBestiaryMissingMode()">
                                <label for="filter-missing-bestiary">Show Missing from Bestiary</label>
                            </div>
                            <!-- Refresh button remains the same -->
                            <button class="btn btn-success" style="margin-left: auto; padding: 5px 10px; display: flex; align-items: center; gap: 5px;" onclick="loadMonsters(); refreshMonsterThumbnails();" title="Refresh monster list">
                                <svg style="width: 16px; height: 16px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M23 4v6h-6M1 20v-6h6M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/>
                                </svg>
                                Refresh
                            </button>
                        </div>

                        <div class="monster-grid" id="monsterGrid">
                            <!-- Monsters will be loaded here -->
                        </div>
                    </div>
                    <button class="btn btn-primary" style="margin-top: 20px;" onclick="startGeneration()">Generate Selected Images to Current Pack</button>
                    <button class="btn btn-success" style="margin-top: 20px;" onclick="showExportToPackModal()">Export Selected to New Pack</button>
                    <button class="btn btn-warning" style="margin-top: 20px; display: none;" id="add-to-bestiary-btn" onclick="addSelectedToBestiary()">Add to Bestiary</button>
                </div>

                <div class="section">
                    <h2>Generation Log</h2>
                    <div class="log-container" id="genLog">
                        <!-- Log entries will appear here -->
                    </div>
                    <div class="progress-container" id="genProgress">
                        <div class="progress-bar">
                            <div class="progress-fill" id="genProgressFill">0%</div>
                        </div>
                        <div class="progress-status" id="genStatus">Preparing...</div>
                    </div>
                </div>
            </div>
            
            <!-- NPC Management & Generator Tab -->
            <div id="npcs-tab" class="tab-content">
                <div class="section">
                    <h2>Generate NPC Portraits<span class="tooltip-trigger" data-tooltip="Generate portrait images for NPCs found in adventure modules. NPCs are module-specific and stored separately from monsters.">?</span></h2>
                    <p style="color: #ff6b35; font-size: 0.85em; margin-top: -10px; margin-bottom: 15px;">
                        Note: NPC assets are for party mechanics only and will not be used for general encounters. Portraits are incorporated only when NPCs join the party.
                    </p>
                    
                    <!-- Top Row: Selectors -->
                    <div class="generator-controls">
                        <div class="generator-options">
                            <div class="form-group option-box blue-outline">
                                <label for="npcModuleSelect">Source Module:<span class="tooltip-trigger" data-tooltip="Select the adventure module to scan for NPCs.">?</span></label>
                                <select id="npcModuleSelect" onchange="loadNpcsForModule()">
                                    <option value="">-- Select a Module --</option>
                                    <!-- Modules will be loaded here -->
                                </select>
                            </div>
                            <div class="form-group option-box orange-outline">
                                <label for="npcPackSelect">Target Pack:<span class="tooltip-trigger" data-tooltip="The graphic pack where new NPC portraits will be saved.">?</span></label>
                                <select id="npcPackSelect" onchange="loadNpcsForModule()">
                                    <!-- Packs will be loaded here -->
                                </select>
                            </div>
                            <div class="form-group option-box orange-outline">
                                <label for="npcStyleSelect">Style Template:<span class="tooltip-trigger" data-tooltip="The artistic style used for portrait generation. You can edit existing prompts or save new custom styles.">?</span></label>
                                <select id="npcStyleSelect" onchange="loadNpcStylePrompt()">
                                    <!-- Styles will be loaded from JSON -->
                                </select>
                            </div>
                            <div class="form-group option-box purple-outline">
                                <label for="npcModelSelect">AI Model:<span class="tooltip-trigger" data-tooltip="The AI model used for generating portraits. DALL-E 3 is the default.">?</span></label>
                                <select id="npcModelSelect" onchange="checkNpcModelWarning()">
                                    <option value="dall-e-3">DALL-E 3 (Default)</option>
                                    <option value="gpt-image-1">GPT-Image (Best Quality)</option>
                                </select>
                                <div class="model-warning" id="npcModelWarning">
                                    Warning: GPT-Image requires a validated OpenAI account with higher tier access.
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Middle Row: Style Prompt & Description Editor -->
                    <div class="prompt-description-section">
                        <div class="preview-layout">
                            <!-- Style Prompt Editor for NPCs -->
                            <div class="prompt-editor">
                                <div class="prompt-editor-header">
                                    <h4>Style Prompt<span class="tooltip-trigger" data-tooltip="The text prompt that defines the artistic style for NPC portraits. Edit this to fine-tune the look of your portraits.">?</span></h4>
                                    <button class="btn btn-small btn-primary" onclick="saveNpcStylePrompt()">Save (Overwrite Style)</button>
                                </div>
                                <textarea id="npcStylePromptBox" class="preview-textarea" placeholder="Select a style template to see its prompt..."></textarea>
                                <div class="save-as-new">
                                    <input type="text" id="newNpcStyleName" placeholder="Save as new style name...">
                                    <button class="btn btn-light btn-small" onclick="saveAsNewNpcStyle()">Save as New</button>
                                </div>
                            </div>
                            
                            <!-- Separator -->
                            <div class="preview-separator">+</div>
                            
                            <!-- NPC Description Editor -->
                            <div class="prompt-editor">
                                <div class="prompt-editor-header">
                                    <h4>NPC Description<span class="tooltip-trigger" data-tooltip="NPC descriptions are pack-specific and stored locally in temp files. This description will be used to generate the portrait. Click 'Fetch Descriptions' to generate them with AI, or edit them manually.">?</span></h4>
                                    <div>
                                        <button class="btn btn-primary btn-small" onclick="fetchNpcDescriptions()">Fetch Descriptions</button>
                                        <button class="btn btn-primary btn-small" onclick="saveNpcDescription()">Save</button>
                                    </div>
                                </div>
                                <textarea id="npcDescriptionBox" class="preview-textarea" placeholder="Select a module, then select an NPC from the list below..."></textarea>
                                <div class="selected-monster-info">
                                    <small id="selectedNpcName">No NPC selected</small>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Bottom Section: NPC List -->
                    <div class="monster-list-container">
                        <div class="monster-list-header">
                            <h4>NPCs Found in Module<span class="tooltip-trigger" data-tooltip="This list shows all NPCs found in the selected module's area files.">?</span></h4>
                            <div class="monster-buttons">
                                <button class="btn btn-light btn-small" onclick="selectAllNpcs(true)">Select All</button>
                                <button class="btn btn-light btn-small" onclick="selectAllNpcs(false)">Select Missing</button>
                                <button class="btn btn-secondary btn-small" onclick="deselectAllNpcs()">Deselect All</button>
                            </div>
                        </div>
                        <div class="npc-list-legend">
                            <div class="legend-item" title="A portrait for this NPC exists in the selected pack's 'npcs' folder.">
                                <span class="legend-color-box bestiary"></span> In Pack <span id="npc-count-exists">(0)</span>
                            </div>
                            <div class="legend-item" title="A portrait for this NPC is missing from the selected pack.">
                                <span class="legend-color-box missing-from-pack"></span> Portrait Missing <span id="npc-count-missing">(0)</span>
                            </div>
                            <!-- The new toggle and counter -->
                            <div class="legend-item" title="Check this to also scan the live 'web/static/portraits' folder. Portraits found here can be exported to the selected pack.">
                                <input type="checkbox" id="filter-include-local" onchange="loadNpcsForModule()">
                                <label for="filter-include-local">
                                    <span class="legend-color-box in-module"></span> Include Local Files <span id="npc-count-local">(0)</span>
                                </label>
                            </div>
                        </div>
                        <div class="monster-grid" id="npcGrid">
                            <!-- NPCs will be loaded here -->
                        </div>
                    </div>
                    <button class="btn btn-primary" style="margin-top: 20px;" onclick="startNpcGeneration()">Generate Selected Portraits</button>
                    <button class="btn btn-success" style="margin-top: 20px;" onclick="exportNpcsToPack()">Export to Pack</button>
                </div>
                
                <!-- Generation Log for NPCs -->
                <div class="section">
                    <h2>Generation Log</h2>
                    <div class="log-container" id="npcGenLog">
                        <!-- NPC generation log entries will appear here -->
                    </div>
                    <div class="progress-container" id="npcGenProgress" style="display: none;">
                        <div class="progress-bar">
                            <div class="progress-fill" id="npcGenProgressFill">0%</div>
                        </div>
                        <div class="progress-status" id="npcGenStatus">Preparing...</div>
                    </div>
                </div>
            </div>
            
            <!-- Video Processor Tab - UPDATED LAYOUT -->
            <div id="videos-tab" class="tab-content">
                <div class="two-column-layout balanced">
                    <!-- Left Column -->
                    <div class="column-left">
                        <div class="section">
                            <h2>Process Monster Videos<span class="tooltip-trigger" data-tooltip="Upload monster videos (e.g., MP4s) here. The tool will compress them and save them into the selected graphic pack with the correct naming convention.">?</span></h2>
                            <div class="form-group">
                                <label for="videoPack">Target Pack:<span class="tooltip-trigger" data-tooltip="The graphic pack where processed videos will be saved.">?</span></label>
                                <select id="videoPack">
                                    <!-- Packs will be loaded here -->
                                </select>
                            </div>
                            <div class="upload-area" id="videoUploadArea">
                                <p>Drag and drop video files here or click to browse</p>
                                <input type="file" id="videoFiles" multiple accept="video/*" style="display:none" onchange="addVideos(this.files)">
                            </div>
                            <div class="file-list" id="videoList">
                                <!-- Video files will be listed here -->
                            </div>
                            <button class="btn btn-primary" style="margin-top: 20px;" onclick="processVideos()">Process Videos</button>
                        </div>
                    </div>
                    <!-- Right Column -->
                    <div class="column-right">
                         <div class="section">
                            <h2>Processing Log<span class="tooltip-trigger" data-tooltip="Shows the real-time status of video processing operations.">?</span></h2>
                            <div class="log-container" id="videoLog">
                                <!-- Log entries will appear here -->
                            </div>
                             <div class="progress-container" id="videoProgress">
                                <div class="progress-bar">
                                    <div class="progress-fill" id="videoProgressFill">0%</div>
                                </div>
                                <div class="progress-status" id="videoStatus">Awaiting files...</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Module Builder Tab -->
            <div id="builder-tab" class="tab-content">
                <div id="main-container">
                    <!-- Left Panel: Builder -->
                    <div class="panel builder-panel">
                        <div class="panel-content">
                            <p class="intro-text">
                                This tool allows for the manual creation of a new adventure module. The AI will generate a complete, playable module based on your concept. The more detail you provide in the prompt, the richer and more tailored the adventure will be.
                            </p>
                    
                            <!-- Input Form -->
                            <form id="module-form">
                                <label for="module-name">Module Name</label>
                                <input type="text" id="module-name" name="module-name" class="game-input" 
                                       placeholder="Enter a unique name for your module (e.g., Shadows_of_Eldoria)" required>
                                
                                <div style="display: flex; gap: 20px; margin-bottom: 20px;">
                                    <div style="flex: 1;">
                                        <label for="num-areas">Number of Areas</label>
                                        <input type="number" id="num-areas" name="num-areas" class="game-input" 
                                               min="1" max="10" value="3" required>
                                    </div>
                                    <div style="flex: 1;">
                                        <label for="locations-per-area">Locations per Area</label>
                                        <input type="number" id="locations-per-area" name="locations-per-area" class="game-input" 
                                               min="1" max="30" value="5" required>
                                    </div>
                                </div>
                                
                                <label for="ai-narrative">Module Concept (AI Narrative Prompt)</label>
                                <textarea id="ai-narrative" name="ai-narrative" class="game-input" rows="8" 
                                          placeholder="Describe your module concept in detail. Include themes, settings, key NPCs, plot hooks, and any specific elements you want included..."
                                          required></textarea>
                                
                                <button type="submit" class="game-button primary" id="generate-btn">Generate Module</button>
                            </form>
                            
                            <!-- Progress Section -->
                            <div id="generation-progress" style="display: none;">
                                <h2>Generation in Progress<span class="spinner"></span></h2>
                                <div id="progress-bar-container">
                                    <div id="progress-bar" style="width: 0%;"></div>
                                    <span id="progress-percentage">0%</span>
                                </div>
                                <ul id="progress-stages">
                                    <li data-stage="0">Initializing</li>
                                    <li data-stage="1">Base Structure</li>
                                    <li data-stage="2">NPCs</li>
                                    <li data-stage="3">Monsters</li>
                                    <li data-stage="4">Areas</li>
                                    <li data-stage="5">Plots</li>
                                    <li data-stage="6">Connections</li>
                                    <li data-stage="7">Finalizing</li>
                                    <li data-stage="8">Saving</li>
                                </ul>
                                <p id="status-message">Initializing module builder...</p>
                                <button class="game-button cancel" id="cancel-btn">Cancel Generation</button>
                            </div>
                            
                            <!-- Results Section -->
                            <div id="results-section" style="display: none;">
                                <h2>Module Created Successfully!</h2>
                                <pre id="module-output"></pre>
                                <button class="game-button" id="new-module-btn">Create Another Module</button>
                            </div>
                            
                            <!-- Error Section -->
                            <div id="error-section" style="display: none;">
                                <div class="error-message" id="error-message"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Right Panel: Existing Modules -->
                    <div class="panel modules-panel">
                        <div class="panel-header">Existing Modules<span class="tooltip-trigger" data-tooltip="This panel lists all modules currently installed in your 'modules' directory, along with their key statistics.">?</span></div>
                        <div class="panel-content" id="modules-list">
                            <div class="no-modules">Loading modules...</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Settings Tab Removed - API key now from config.py -->
        </div>
    </div>
    
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <script>
        // Socket.IO connection
        const socket = io();
        
        // Current state
        let currentTab = 'overview';
        let availablePacks = [];
        let monsterList = [];
        let videoQueue = [];
        let activePack = null;
        let fileToImport = null; // To hold the selected file
        // Removed isInitialLoad flag - no longer needed with new event listener approach
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            loadStyles();
            loadPacks();
            loadMonsters();
            loadModules(); // Load available modules for cross-reference
            loadNpcModules(); // Load modules for NPC tab
            
            // Initialize model warnings as hidden
            checkModelWarning();
            checkNpcModelWarning();
            setupDragDrop();
            setupSocketHandlers();
            initializeModuleBuilderElements(); // Initialize module builder DOM elements
            setupModuleBuilderEventListeners(); // Set up module builder event listeners
            
            // If builder tab is active on load, request modules
            const activeTab = document.querySelector('.tab.active');
            if (activeTab && activeTab.textContent.includes('Module Builder')) {
                console.log('Module Builder tab is active on load, requesting modules...');
                socket.emit('request_module_list');
            }
        });
        
        // Tab switching
        function switchTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(`${tab}-tab`).classList.add('active');
            currentTab = tab;
            
            // Load styles when switching to generator tab
            if (tab === 'generator') {
                loadStyles();
                loadMonsters();
            } else if (tab === 'npcs') {
                // Load NPC modules and packs when switching to NPC tab
                loadNpcModules();
                loadNpcPacks();
            } else if (tab === 'builder') {
                // Request module list when switching to builder tab
                console.log('Switching to builder tab, requesting module list...');
                socket.emit('request_module_list');
            }
        }
        
        // Graphic Pack Management
        async function loadPacks() {
            try {
                const response = await fetch('/api/toolkit/packs');
                availablePacks = await response.json();
                renderPacks();
                updatePackSelectors();
            } catch (error) {
                console.error('Failed to load packs:', error);
            }
        }
        
        function renderPacks() {
            const grid = document.getElementById('packGrid');
            grid.innerHTML = '';
            
            availablePacks.forEach(pack => {
                const row = document.createElement('div');
                row.className = 'pack-list-row';
                
                const monsterCount = pack.total_monsters || pack.monsters_count || 0;
                const npcCount = pack.total_npcs || 0;
                const videoCount = pack.total_videos || 0;
                const author = pack.author || 'Unknown';
                const style = pack.style || pack.style_template || 'custom';
                const isDefault = pack.name === 'photorealistic';
                
                // --- NEW HTML STRUCTURE WITH BUTTONS ---
                row.innerHTML = `
                    <div class="pack-list-cell">
                        <!-- Replaced radio button with a non-interactive status indicator -->
                        <div class="pack-status-indicator ${pack.is_active ? 'active' : ''}" title="${pack.is_active ? 'Currently Active' : 'Inactive'}"></div>
                    </div>
                    <div class="pack-list-cell pack-name-cell">
                        ${pack.display_name || pack.name}
                    </div>
                    <div class="pack-list-cell pack-meta-cell">
                        Author: ${author} | Style: ${style} | Version: ${pack.version || '1.0.0'}
                    </div>
                    <div class="pack-list-cell pack-stats-cell">
                        <div class="stat">
                            <div class="stat-value">${monsterCount}</div>
                            <div class="stat-label">Monsters</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value">${npcCount}</div>
                            <div class="stat-label">NPCs</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value">${videoCount}</div>
                            <div class="stat-label">Videos</div>
                        </div>
                    </div>
                    <div class="pack-list-cell pack-actions-cell">
                        ${pack.is_active 
                            ? `<button class="btn btn-secondary" disabled>Active</button>`
                            : `<button class="btn-icon btn-success" onclick="showPackConfirmation('${pack.name}')" title="Activate Pack">
                                    <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>
                                </button>`
                        }
                        <button class="btn-icon btn-secondary" onclick="exportPack('${pack.name}')" title="Export Pack">
                            <svg viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                        </button>
                        ${(!pack.is_active) 
                            ? `<button class="btn-icon btn-primary" onclick="showMergeConfirmation('${pack.name}')" title="Merge into Active Pack">
                                    <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                                </button>` 
                            : ''
                        }
                        ${(!isDefault && !pack.is_active) 
                            ? `<button class="btn-icon btn-danger" onclick="deletePack('${pack.name}')" title="Delete Pack">
                                    <svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
                                </button>` 
                            : ''
                        }
                    </div>
                `;
                grid.appendChild(row);
            });
        }
        
        function updatePackSelectors() {
            const selectors = ['genPack', 'videoPack'];
            selectors.forEach(id => {
                const select = document.getElementById(id);
                if (select) {
                    // Save current selection before updating
                    const currentValue = select.value;
                    
                    select.innerHTML = '';
                    
                    availablePacks.forEach(pack => {
                        const option = document.createElement('option');
                        option.value = pack.name;
                        option.textContent = pack.display_name || pack.name;
                        select.appendChild(option);
                    });
                    
                    // Restore previous selection if it still exists
                    if (currentValue && availablePacks.some(p => p.name === currentValue)) {
                        select.value = currentValue;
                    } else if (availablePacks.some(p => p.is_active)) {
                        // Only fall back to active pack if previous selection doesn't exist
                        const activePack = availablePacks.find(p => p.is_active);
                        select.value = activePack.name;
                    }
                }
            });
        }
        
        // Removed the complex style auto-selection functions that were causing issues
        
        async function createNewPack() {
            const name = document.getElementById('new-pack-name').value.trim();
            const displayName = document.getElementById('new-pack-display-name').value.trim();
            const author = document.getElementById('new-pack-author').value.trim();
            const description = document.getElementById('new-pack-description').value.trim();

            if (!name || !displayName) {
                alert('Pack Name and Display Name are required.');
                return;
            }

            // Basic validation for the internal ID
            if (/\s/.test(name) || name !== name.toLowerCase()) {
                alert('Pack Name (Internal ID) must be all lowercase with no spaces.');
                return;
            }

            try {
                const response = await fetch('/api/toolkit/packs/create', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: name,
                        display_name: displayName,
                        author: author || 'Module Toolkit User',
                        description: description
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    addLog('genLog', `Successfully created new pack: ${displayName}`, 'success');
                    // Clear the form fields
                    document.getElementById('new-pack-name').value = '';
                    document.getElementById('new-pack-display-name').value = '';
                    document.getElementById('new-pack-author').value = '';
                    document.getElementById('new-pack-description').value = '';
                    // Refresh the list of available packs
                    loadPacks();
                } else {
                    alert(`Failed to create pack: ${result.error}`);
                }
            } catch (error) {
                console.error('Error creating pack:', error);
                alert('An error occurred while creating the pack.');
            }
        }
        
        // Global variables for pack confirmation
        let pendingPackActivation = null;

        function showPackConfirmation(packName) {
            // Don't show confirmation if the pack is already active
            const currentPack = availablePacks.find(p => p.is_active);
            if (currentPack && currentPack.name === packName) {
                return;
            }
            
            // Store the pending activation
            pendingPackActivation = packName;
            
            const currentPackName = currentPack ? (currentPack.display_name || currentPack.name) : 'None';
            
            // Generate backup name with date
            const now = new Date();
            const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
            const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, ''); // HHMMSS
            const backupName = `${currentPack ? currentPack.name : 'unknown'}_backup_${dateStr}_${timeStr}`;
            
            // Update modal content
            document.getElementById('backup-name-preview').textContent = backupName;
            document.getElementById('activating-pack-name').textContent = packName;
            document.getElementById('current-pack-name').textContent = currentPackName;
            
            // Show modal
            document.getElementById('pack-confirm-modal').style.display = 'flex';
        }

        function cancelPackActivation() {
            // Hide modal
            document.getElementById('pack-confirm-modal').style.display = 'none';
            pendingPackActivation = null;
        }

        async function confirmPackActivation() {
            if (!pendingPackActivation) return;
            
            const packName = pendingPackActivation;
            
            // Hide modal
            document.getElementById('pack-confirm-modal').style.display = 'none';
            
            try {
                const response = await fetch(`/api/toolkit/packs/${packName}/activate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        create_backup: true
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    addLog('genLog', `Activated pack: ${packName}`, 'success');
                    if (result.backup_created) {
                        addLog('genLog', `Backup created: ${result.backup_name}`, 'info');
                    }
                    loadPacks();
                } else {
                    alert(`Failed to activate pack: ${result.error}`);
                }
            } catch (error) {
                console.error('Failed to activate pack:', error);
                alert('Failed to activate pack. Please check the console for details.');
            }
            
            pendingPackActivation = null;
        }
        
        async function exportPack(packName) {
            try {
                // Show export notification
                const notification = document.createElement('div');
                notification.className = 'export-notification';
                notification.innerHTML = `
                    <div class="notification-content">
                        <h4>Exporting Pack...</h4>
                        <p>Preparing ${packName} for download...</p>
                    </div>
                `;
                document.body.appendChild(notification);
                
                // Trigger the download
                window.location.href = `/api/toolkit/packs/${packName}/export`;
                
                // Update notification after a short delay
                setTimeout(() => {
                    notification.innerHTML = `
                        <div class="notification-content success">
                            <h4> Export Complete</h4>
                            <p>${packName}.zip has been downloaded to your default Downloads folder</p>
                            <button onclick="this.parentElement.parentElement.remove()">OK</button>
                        </div>
                    `;
                    
                    // Auto-remove after 5 seconds
                    setTimeout(() => {
                        if (notification.parentElement) {
                            notification.remove();
                        }
                    }, 5000);
                }, 1500);
                
            } catch (error) {
                console.error('Failed to export pack:', error);
                addLog('genLog', `Export failed: ${error}`, 'error');
            }
        }
        
        async function deletePack(packName) {
            // This uses the standard browser confirmation dialog, which is guaranteed to work.
            if (confirm(`Are you sure you want to permanently delete the pack "${packName}"? This action cannot be undone.`)) {
                try {
                    const response = await fetch(`/api/toolkit/packs/${packName}`, {
                        method: 'DELETE'
                    });
                    
                    const result = await response.json();
                    if (result.success) {
                        addLog('genLog', `Deleted pack: ${packName}`, 'success');
                        loadPacks();
                    } else {
                        alert(`Failed to delete pack: ${result.error}`);
                    }
                } catch (error) {
                    console.error('Failed to delete pack:', error);
                    alert('An error occurred while trying to delete the pack.');
                }
            }
        }
        
        // Merge Pack Functions
        let pendingPackMerge = null;

        function showMergeConfirmation(sourcePackName) {
            const destPack = availablePacks.find(p => p.is_active);
            if (!destPack) {
                alert('Cannot merge because there is no active pack to merge into.');
                return;
            }

            pendingPackMerge = sourcePackName;
            
            document.getElementById('merge-source-pack').textContent = sourcePackName;
            document.getElementById('merge-dest-pack').textContent = destPack.display_name || destPack.name;
            document.getElementById('merge-confirm-modal').style.display = 'flex';
        }

        function cancelMerge() {
            document.getElementById('merge-confirm-modal').style.display = 'none';
            pendingPackMerge = null;
        }

        async function confirmMerge() {
            if (!pendingPackMerge) return;

            const sourcePackName = pendingPackMerge;
            cancelMerge(); // Hide modal and clear pending state immediately

            addLog('genLog', `Starting merge from '${sourcePackName}'...`, 'info');

            try {
                const response = await fetch(`/api/toolkit/packs/${sourcePackName}/merge`, {
                    method: 'POST'
                });
                const result = await response.json();

                if (result.success) {
                    addLog('genLog', result.message, 'success');
                    // Reload packs to show updated monster/video counts in the active pack
                    await loadPacks(); 
                } else {
                    addLog('genLog', `Merge failed: ${result.error}`, 'error');
                    alert(`Merge failed: ${result.error}`);
                }
            } catch (error) {
                addLog('genLog', `Merge failed with a network error: ${error}`, 'error');
                alert(`An error occurred during the merge process.`);
            }
        }
        
        // Export to Pack Functions
        function showExportToPackModal() {
            const selectedMonsters = Array.from(document.querySelectorAll('input[name="monster"]:checked'))
                .map(cb => cb.value);
            
            if (selectedMonsters.length === 0) {
                alert('Please select at least one monster to export.');
                return;
            }
            
            // Get current pack name to use as source
            const currentPack = document.getElementById('genPack').value;
            if (!currentPack || currentPack === '__new__') {
                alert('Please select a valid source pack first.');
                return;
            }
            
            // Update monster count in modal
            document.getElementById('export-monster-count').textContent = selectedMonsters.length;
            
            // Suggest a pack name based on module
            const moduleName = document.getElementById('genModule').value;
            if (moduleName) {
                const suggestedName = moduleName.toLowerCase().replace(/[^a-z0-9]/g, '_') + '_pack';
                document.getElementById('export-pack-name').value = suggestedName;
                
                // Suggest display name
                const moduleOption = document.querySelector(`#genModule option[value="${moduleName}"]`);
                if (moduleOption) {
                    document.getElementById('export-pack-display-name').value = moduleOption.textContent + ' Monster Pack';
                }
            }
            
            // Show modal
            document.getElementById('export-to-pack-modal').style.display = 'flex';
        }
        
        function cancelExportToPack() {
            document.getElementById('export-to-pack-modal').style.display = 'none';
            // Clear form
            document.getElementById('export-pack-name').value = '';
            document.getElementById('export-pack-display-name').value = '';
            document.getElementById('export-pack-author').value = '';
            document.getElementById('export-pack-description').value = '';
            document.getElementById('export-pack-style').value = '';
        }
        
        async function confirmExportToPack() {
            // Gather pack information
            const packName = document.getElementById('export-pack-name').value.trim();
            const displayName = document.getElementById('export-pack-display-name').value.trim();
            const author = document.getElementById('export-pack-author').value.trim();
            const description = document.getElementById('export-pack-description').value.trim();
            const style = document.getElementById('export-pack-style').value.trim() || 'custom';
            
            // Validate pack name
            if (!packName || !/^[a-z0-9_]+$/.test(packName)) {
                alert('Pack name must contain only lowercase letters, numbers, and underscores.');
                return;
            }
            
            if (!displayName) {
                alert('Please provide a display name for the pack.');
                return;
            }
            
            if (!author) {
                alert('Please provide an author name.');
                return;
            }
            
            // Get selected monsters
            const selectedMonsters = Array.from(document.querySelectorAll('input[name="monster"]:checked'))
                .map(cb => cb.value);
            
            // Get source pack
            const sourcePack = document.getElementById('genPack').value;
            
            // Close modal
            cancelExportToPack();
            
            // Show progress
            addLog('genLog', `Creating new pack "${displayName}"...`, 'info');
            
            try {
                const response = await fetch('/api/toolkit/export-monsters-to-pack', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        pack_name: packName,
                        display_name: displayName,
                        author: author,
                        description: description,
                        style: style,
                        source_pack: sourcePack,
                        monster_ids: selectedMonsters
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    addLog('genLog', `Successfully created pack: ${displayName}`, 'success');
                    addLog('genLog', `Exported ${result.exported_count} monsters`, 'success');
                    if (result.skipped && result.skipped.length > 0) {
                        addLog('genLog', `Skipped ${result.skipped.length} monsters (not found in source)`, 'warning');
                    }
                    
                    // Reload packs list
                    await loadPacks();
                    
                    // Option to download the pack
                    if (confirm(`Pack created successfully! Would you like to download it as a ZIP file?`)) {
                        window.location.href = `/api/toolkit/packs/${packName}/export`;
                    }
                } else {
                    addLog('genLog', `Failed to create pack: ${result.error}`, 'error');
                    alert(`Failed to create pack: ${result.error}`);
                }
            } catch (error) {
                addLog('genLog', `Error creating pack: ${error}`, 'error');
                alert(`An error occurred while creating the pack.`);
            }
        }
        
        // This new global variable will hold the file for the confirmation step
        async function handleFileSelection(files) {
            if (files.length === 0) return;

            const file = files[0];
            fileToImport = file;
            
            const filePathDisplay = document.getElementById('file-path-display');
            const previewArea = document.getElementById('import-preview-area');
            const metadataDiv = document.getElementById('preview-metadata');
            const targetFolderInput = document.getElementById('target-folder-name');
            const confirmBtn = document.getElementById('confirm-import-btn');

            filePathDisplay.textContent = file.name;
            metadataDiv.innerHTML = '<em>Reading pack manifest...</em>';
            previewArea.style.display = 'block';
            confirmBtn.disabled = false; // Re-enable button on new selection

            const formData = new FormData();
            formData.append('pack', file);

            try {
                const response = await fetch('/api/toolkit/packs/preview', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    const data = result.data;
                    
                    // Update asset counts in checkboxes
                    const monsterCount = data.total_monsters || 0;
                    const npcCount = data.total_npcs || 0;
                    
                    document.getElementById('monsters-count-label').textContent = `Import Monsters (${monsterCount} found)`;
                    document.getElementById('npcs-count-label').textContent = `Import NPCs (${npcCount} found)`;
                    
                    // Disable checkboxes if no assets of that type
                    document.getElementById('import-monsters').disabled = monsterCount === 0;
                    document.getElementById('import-npcs').disabled = npcCount === 0;
                    
                    // Auto-uncheck if no assets
                    if (monsterCount === 0) document.getElementById('import-monsters').checked = false;
                    if (npcCount === 0) document.getElementById('import-npcs').checked = false;
                    
                    metadataDiv.innerHTML = `
                        <strong>Name:</strong> ${data.display_name || data.name}<br>
                        <strong>Author:</strong> ${data.author || 'N/A'}<br>
                        <strong>Version:</strong> ${data.version || 'N/A'}<br>
                        <strong>Style:</strong> ${data.style_template || 'custom'}<br>
                        <strong>Description:</strong> ${data.description || 'No description provided.'}<br>
                        <strong>Contents:</strong> ${monsterCount} monsters, ${npcCount} NPCs, ${data.total_videos || 0} videos
                    `;
                    // Populate the editable folder name input
                    targetFolderInput.value = data.name;
                } else {
                    metadataDiv.innerHTML = `<span style="color: #f44336;">Error: ${result.error}</span>`;
                    confirmBtn.disabled = true;
                }
            } catch (error) {
                metadataDiv.innerHTML = `<span style="color: #f44336;">Error: Could not contact server for preview.</span>`;
                confirmBtn.disabled = true;
            }
        }

        function confirmImport() {
            const targetFolderName = document.getElementById('target-folder-name').value;
            if (!targetFolderName) {
                alert('Destination folder name cannot be empty.');
                return;
            }
            
            const importMonsters = document.getElementById('import-monsters').checked;
            const importNpcs = document.getElementById('import-npcs').checked;
            
            if (!importMonsters && !importNpcs) {
                alert('Please select at least one asset type to import.');
                return;
            }

            if (fileToImport) {
                uploadAndImportPack(fileToImport, targetFolderName, importMonsters, importNpcs);
                
                document.getElementById('import-preview-area').style.display = 'none';
                document.getElementById('file-path-display').textContent = 'No file selected...';
                document.getElementById('importFile').value = '';
                fileToImport = null;
            } else {
                alert('No file selected for import.');
            }
        }

        // RENAME this function from importPack to uploadAndImportPack
        async function uploadAndImportPack(file, targetFolderName, importMonsters = true, importNpcs = true) {
            const formData = new FormData();
            formData.append('pack', file);
            formData.append('target_folder_name', targetFolderName);
            formData.append('import_monsters', importMonsters);
            formData.append('import_npcs', importNpcs);
            
            // Show what's being imported
            const importTypes = [];
            if (importMonsters) importTypes.push('monsters');
            if (importNpcs) importTypes.push('NPCs');
            
            addLog('genLog', `Importing ${importTypes.join(' and ')} from pack...`, 'info');
            
            try {
                const response = await fetch('/api/toolkit/packs/import', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                if (result.success) {
                    const importSummary = [];
                    if (result.monsters_imported > 0) importSummary.push(`${result.monsters_imported} monsters`);
                    if (result.npcs_imported > 0) importSummary.push(`${result.npcs_imported} NPCs`);
                    
                    addLog('genLog', `Imported pack: ${result.pack_name} (${importSummary.join(', ')})`, 'success');
                    loadPacks();
                } else {
                    alert(`Failed to import pack: ${result.error}`);
                }
            } catch (error) {
                console.error('Failed to import pack:', error);
                addLog('genLog', `Failed to import pack: ${error.message}`, 'error');
            }
        }
        
        // Monster Generation
        async function loadMonsters() {
            // Reset missing bestiary mode when loading new monsters
            if (document.getElementById('filter-missing-bestiary')) {
                document.getElementById('filter-missing-bestiary').checked = false;
                toggleBestiaryMissingMode();
            }
            
            try {
                // Get current pack to scan for additional monsters
                const packName = document.getElementById('genPack').value || 'photorealistic';
                const response = await fetch(`/api/toolkit/monsters?pack=${packName}`);
                const monsters = await response.json();
                // We pass the monster list directly to renderMonsters now
                renderMonsters(monsters);
            } catch (error) {
                console.error('Failed to load monsters:', error);
            }
        }
        
        function renderMonsters(monstersToRender, isModuleView = false) {
            const grid = document.getElementById('monsterGrid');
            grid.innerHTML = '';

            // Initialize counters
            let bestiaryCount = 0;
            let packOnlyCount = 0;
            let missingCount = 0;
            let inModuleCount = 0;

            monstersToRender.forEach(monster => {
                const item = document.createElement('div');
                let sourceClass = '';

                // Determine source class for the left-side highlight
                switch (monster.source) {
                    case 'bestiary':
                        bestiaryCount++;
                        sourceClass = 'monster-bestiary';
                        break;
                    case 'pack_only':
                        packOnlyCount++;
                        sourceClass = 'monster-pack-only';
                        break;
                    case 'bestiary_only':
                        missingCount++;
                        sourceClass = 'monster-bestiary-only';
                        break;
                }
                
                item.className = `monster-item ${sourceClass}`;

                // Add the blue right-side highlight if the monster is in the selected module
                if (monster.inModule) {
                    item.classList.add('monster-in-module');
                    inModuleCount++;
                }

                // Build the inner HTML for the monster tile
                if (monster.isPlaceholder) {
                    // This is a monster from the module that doesn't exist in the pack.
                    // Render a disabled-looking placeholder.
                    item.classList.add('placeholder-monster');
                    item.innerHTML = `
                        <label class="monster-label" style="opacity: 0.6;">
                            <input type="checkbox" value="${monster.id}" name="monster" disabled>
                            <span>${monster.name}</span>
                        </label>
                        <div class="monster-thumbnail-preview">
                            <div class="no-image-placeholder" style="color: #f44336;">!</div>
                        </div>
                    `;
                } else {
                    // This is a standard monster tile
                    item.innerHTML = `
                        <label class="monster-label">
                            <input type="checkbox" value="${monster.id}" name="monster" onchange="handleMonsterSelection('${monster.id}')">
                            <span>${monster.name}</span>
                        </label>
                        <div class="monster-thumbnail-preview" id="thumb-${monster.id}">
                            <!-- Thumbnail will be loaded here by JS -->
                        </div>
                    `;
                }
                
                grid.appendChild(item);

                // Load the thumbnail only if it's not a placeholder
                if (!monster.isPlaceholder) {
                    loadMonsterThumbnail(monster.id);
                }
            });

            // Update the legend counts in the HTML
            document.getElementById('count-bestiary').textContent = `(${bestiaryCount})`;
            document.getElementById('count-pack-only').textContent = `(${packOnlyCount})`;
            document.getElementById('count-missing').textContent = `(${missingCount})`;
            document.getElementById('count-in-module').textContent = `(${inModuleCount})`;
            
            // Update the button text based on current selection
            updateSelectionStatus();
            
            // Re-apply any active filters after rendering is complete
            applyLegendFilters();
        }
        
        function selectAllMonsters() {
            // Find only the monster items that are currently visible
            document.querySelectorAll('.monster-item').forEach(item => {
                if (item.style.display !== 'none') {
                    const checkbox = item.querySelector('input[name="monster"]');
                    if (checkbox && !checkbox.disabled) {
                        checkbox.checked = true;
                    }
                }
            });
            updateSelectionStatus(); // Update the button text
        }
        
        function deselectAllMonsters() {
            document.querySelectorAll('input[name="monster"]').forEach(cb => cb.checked = false);
            document.getElementById('monsterDescriptionBox').value = 'Select a monster from the list to see its description...';
            document.getElementById('selectedMonsterName').textContent = 'No monster selected';
            updateSelectionStatus();
        }
        
        // Enhanced thumbnail loader with video detection
        function loadMonsterThumbnail(monsterId, forceRefresh = false) {
            const thumbContainer = document.getElementById(`thumb-${monsterId}`);
            if (!thumbContainer) {
                console.error(`Thumbnail container not found for ${monsterId}`);
                return;
            }
            
            // Get current pack from dropdown - NO HARDCODED FALLBACK
            const packName = document.getElementById('genPack').value;
            if (!packName || packName === '__new__') {
                console.log(`No valid pack selected for loading thumbnail of ${monsterId}`);
                return;
            }
            console.log(`Loading thumbnail for ${monsterId} from pack ${packName}`);

            // Only use cache busting when explicitly refreshing
            const cacheBuster = forceRefresh ? `?t=${new Date().getTime()}` : '';
            const thumbUrl = `/toolkit/pack_image/${packName}/${monsterId}_thumb.jpg${cacheBuster}`;
            const fullImageUrl = `/toolkit/pack_image/${packName}/${monsterId}.jpg${cacheBuster}`;
            const videoUrl = `/toolkit/pack_video/${packName}/${monsterId}_video.mp4${cacheBuster}`;
            
            console.log(`Thumbnail URL: ${thumbUrl}`);
            
            const img = new Image();
            
            img.onload = () => {
                console.log(`Thumbnail loaded for ${monsterId}`);
                thumbContainer.innerHTML = '';
                thumbContainer.appendChild(img);
                // Store URLs without cache buster for consistent references
                thumbContainer.dataset.thumbSrc = `/toolkit/pack_image/${packName}/${monsterId}_thumb.jpg`;
                thumbContainer.dataset.imageSrc = `/toolkit/pack_image/${packName}/${monsterId}.jpg`;
                
                // Make the container clickable with cursor pointer
                thumbContainer.style.cursor = 'pointer';

                // Now check if a video exists
                fetch(videoUrl, { method: 'HEAD' })
                    .then(res => {
                        if (res.ok) {
                            console.log(`Video found for ${monsterId}`);
                            // Video exists, add indicator and click listener
                            thumbContainer.dataset.videoSrc = videoUrl;
                            const indicator = document.createElement('div');
                            indicator.className = 'video-indicator';
                            indicator.innerHTML = '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>';
                            thumbContainer.appendChild(indicator);
                            thumbContainer.addEventListener('click', showMediaPopup);
                        } else {
                            console.log(`No video for ${monsterId}, image only`);
                            // No video, just add click listener for image
                            thumbContainer.addEventListener('click', showMediaPopup);
                        }
                    })
                    .catch((err) => {
                        console.log(`Error checking video for ${monsterId}:`, err);
                        // If fetch fails, assume no video and add click for image only
                        thumbContainer.addEventListener('click', showMediaPopup);
                    });
            };
            
            img.onerror = () => {
                console.error(`Failed to load thumbnail for ${monsterId} from ${thumbUrl}`);
                thumbContainer.innerHTML = '<div class="no-image-placeholder">?</div>';
                const monsterItem = thumbContainer.closest('.monster-item');
                if (monsterItem) {
                    monsterItem.dataset.missingImage = "true";
                }
            };
            
            // Set the source after handlers are attached
            img.src = thumbUrl;
        }
        
        // Select all monsters without images
        function selectMissingImages() {
            deselectAllMonsters();
            document.querySelectorAll('.monster-item[data-missing-image="true"]').forEach(item => {
                const checkbox = item.querySelector('input[type="checkbox"]');
                if (checkbox && !checkbox.disabled) {
                    checkbox.checked = true;
                }
            });
            updateSelectionStatus();
        }
        
        // Refresh thumbnails when pack changes
        function refreshMonsterThumbnails() {
            // Re-render all monsters to reload thumbnails with cache busting
            if (monsterList && monsterList.length > 0) {
                // Force refresh all thumbnails
                monsterList.forEach(monster => {
                    loadMonsterThumbnail(monster.id, true); // true = force refresh
                });
            }
        }

        // Module cross-reference functions
        async function loadModules() {
            try {
                const response = await fetch('/api/toolkit/modules');
                const modules = await response.json();
                const select = document.getElementById('genModule');
                // Clear existing options except the first one
                select.innerHTML = '<option value="">-- Select a Module --</option>'; 
                modules.forEach(module => {
                    const option = document.createElement('option');
                    option.value = module.moduleName;
                    // Prettify the name for display (e.g., "shadows_of_eldoria" -> "Shadows Of Eldoria")
                    option.textContent = module.moduleName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Failed to load modules:', error);
            }
        }

        async function crossReferenceModuleMonsters() {
            // Reset missing bestiary mode when changing module reference
            if (document.getElementById('filter-missing-bestiary')) {
                document.getElementById('filter-missing-bestiary').checked = false;
                toggleBestiaryMissingMode();
            }
            
            const moduleName = document.getElementById('genModule').value;

            // If the user deselects the module, revert to the standard monster list
            if (!moduleName) {
                loadMonsters(); // This will load and render the default list
                return;
            }

            try {
                // Step 1: Fetch the monster list for the selected module
                const moduleResponse = await fetch(`/api/toolkit/modules/${moduleName}/monsters`);
                const moduleMonsters = await moduleResponse.json();

                // Step 2: Fetch the standard monster list for the current pack (we still need this for source info)
                const packName = document.getElementById('genPack').value || 'photorealistic';
                const packResponse = await fetch(`/api/toolkit/monsters?pack=${packName}`);
                const packAndBestiaryMonsters = await packResponse.json();

                // Step 3: Merge the two lists into a single, comprehensive list
                const monsterMap = new Map();

                // First, process the monsters from the pack and bestiary
                packAndBestiaryMonsters.forEach(monster => {
                    monsterMap.set(monster.id, { ...monster, inModule: false });
                });

                // Next, process monsters from the module, updating or adding as needed
                moduleMonsters.forEach(monsterId => {
                    if (monsterMap.has(monsterId)) {
                        // If the monster already exists, just mark it as being in the module
                        monsterMap.get(monsterId).inModule = true;
                    } else {
                        // If it doesn't exist, it's missing from the pack AND bestiary. Add it as a placeholder.
                        monsterMap.set(monsterId, {
                            id: monsterId,
                            name: monsterId.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                            source: 'bestiary_only', // Treat it as missing from the pack
                            inModule: true,
                            isPlaceholder: true // A flag to indicate we need to render a placeholder tile
                        });
                    }
                });

                // Convert the map back to an array and sort alphabetically by name
                const combinedList = Array.from(monsterMap.values()).sort((a, b) => a.name.localeCompare(b.name));

                // Step 4: Render the final, combined list
                renderMonsters(combinedList, true); // Pass a flag indicating it's a module view

            } catch (error) {
                console.error(`Failed to get and merge monsters for module ${moduleName}:`, error);
            }
        }

        function clearModuleCrossReference() {
            const select = document.getElementById('genModule');
            select.value = ""; // Reset dropdown to the default option
            loadMonsters(); // Re-load the default monster list for the pack
        }
        
        // This new function replaces the old generateMonsters()
        async function startGeneration() {
            const packName = document.getElementById('genPack').value;
            const style = document.getElementById('genStyle').value;
            const model = document.getElementById('genModel').value;
            
            const selectedMonsters = Array.from(document.querySelectorAll('input[name="monster"]:checked'))
                .map(cb => cb.value);

            if (!packName || packName === '__new__') {
                alert('Please select a valid Target Pack.');
                return;
            }

            if (selectedMonsters.length === 0) {
                alert('Please select at least one monster to generate.');
                return;
            }

            // Show confirmation popup with generation settings
            const confirmationDiv = document.createElement('div');
            confirmationDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #2a2a2a;
                border: 2px solid #ff9800;
                border-radius: 8px;
                padding: 20px;
                z-index: 10000;
                box-shadow: 0 4px 20px rgba(0,0,0,0.5);
                min-width: 400px;
                color: white;
            `;
            
            confirmationDiv.innerHTML = `
                <h3 style="margin: 0 0 20px 0; color: #ff9800;">Confirm Image Generation</h3>
                <div style="margin-bottom: 15px;">
                    <strong>Target Pack:</strong> <span style="color: #4CAF50;">${packName}</span>
                </div>
                <div style="margin-bottom: 15px;">
                    <strong>Style Template:</strong> <span style="color: #4CAF50;">${style || 'Default'}</span>
                </div>
                <div style="margin-bottom: 15px;">
                    <strong>AI Model:</strong> <span style="color: #4CAF50;">${model}</span>
                </div>
                <div style="margin-bottom: 20px;">
                    <strong>Monsters to Generate:</strong> <span style="color: #4CAF50;">${selectedMonsters.length} selected</span>
                </div>
                <div style="text-align: center;">
                    <button onclick="proceedWithGeneration()" style="padding: 8px 20px; margin-right: 10px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Proceed</button>
                    <button onclick="cancelGeneration()" style="padding: 8px 20px; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
                </div>
            `;
            
            document.body.appendChild(confirmationDiv);
            
            // Store settings for proceedWithGeneration
            window.generationSettings = {
                packName,
                style,
                model,
                selectedMonsters,
                confirmationDiv
            };
        }

        function cancelGeneration() {
            if (window.generationSettings && window.generationSettings.confirmationDiv) {
                window.generationSettings.confirmationDiv.remove();
                delete window.generationSettings;
            }
        }

        async function proceedWithGeneration() {
            if (!window.generationSettings) return;
            
            const { packName, style, model, selectedMonsters, confirmationDiv } = window.generationSettings;
            
            // Remove confirmation dialog
            confirmationDiv.remove();
            delete window.generationSettings;

            // Check if any of the selected monsters already have images in the pack
            try {
                const checkResponse = await fetch('/api/toolkit/check_existing_images', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        pack_name: packName,
                        monster_ids: selectedMonsters
                    })
                });

                if (checkResponse.ok) {
                    const checkResult = await checkResponse.json();
                    if (checkResult.existing && checkResult.existing.length > 0) {
                        const existingList = checkResult.existing.join(', ');
                        const confirmMessage = `The following monsters already have images in the ${packName} pack:\n\n${existingList}\n\nDo you want to overwrite them?`;
                        
                        if (!confirm(confirmMessage)) {
                            return; // User cancelled
                        }
                    }
                }
            } catch (error) {
                console.warn('Could not check for existing images:', error);
                // Continue anyway if check fails
            }

            const progressContainer = document.getElementById('genProgress');
            const logContainer = document.getElementById('genLog');
            const statusEl = document.getElementById('genStatus');

            if (progressContainer) progressContainer.style.display = 'block';
            if (logContainer) logContainer.style.display = 'block';
            if (statusEl) statusEl.textContent = 'Starting generation...';

            try {
                const response = await fetch('/api/toolkit/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        pack_name: packName,
                        style: style,
                        model: model,
                        monsters: selectedMonsters
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Server error: ${response.status} - ${errorText}`);
                }

                const result = await response.json();
                if (result.success && result.task_id) {
                    addLog('genLog', `Started generation task: ${result.task_id}`, 'info');
                    addLog('genLog', `Generating ${selectedMonsters.length} monsters using the '${style}' style.`, 'info');
                } else {
                    const errorMsg = result.error || 'Unknown error';
                    addLog('genLog', `Failed to start generation: ${errorMsg}`, 'error');
                    if (progressContainer) progressContainer.style.display = 'none';
                }
            } catch (error) {
                console.error('Failed to start generation task:', error);
                addLog('genLog', `Error: ${error.message}`, 'error');
                if (progressContainer) progressContainer.style.display = 'none';
            }
        }
        
        // Video Processing
        function setupDragDrop() {
            const areas = ['importArea', 'videoUploadArea'];
            areas.forEach(id => {
                const area = document.getElementById(id);
                if (!area) return;
                
                area.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    area.classList.add('dragover');
                });
                
                area.addEventListener('dragleave', () => {
                    area.classList.remove('dragover');
                });
                
                area.addEventListener('drop', (e) => {
                    e.preventDefault();
                    area.classList.remove('dragover');
                    
                    if (id === 'importArea') {
                        const file = e.dataTransfer.files[0];
                        if (file && file.name.endsWith('.zip')) {
                            importPack(file);
                        }
                    } else if (id === 'videoUploadArea') {
                        addVideos(e.dataTransfer.files);
                    }
                });
            });
            
            document.getElementById('videoUploadArea')?.addEventListener('click', () => {
                document.getElementById('videoFiles').click();
            });
        }
        
        function addVideos(files) {
            const list = document.getElementById('videoList');
            
            Array.from(files).forEach(file => {
                if (file.type.startsWith('video/')) {
                    videoQueue.push(file);
                    
                    const item = document.createElement('div');
                    item.className = 'file-item';
                    item.innerHTML = `
                        <span>${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)</span>
                        <input type="text" placeholder="Monster ID (e.g., skeleton)" class="monster-id" data-file="${file.name}">
                    `;
                    list.appendChild(item);
                }
            });
        }
        
        async function processVideos() {
            const pack = document.getElementById('videoPack').value;
            const videos = [];
            
            document.querySelectorAll('.monster-id').forEach(input => {
                const fileName = input.dataset.file;
                const monsterId = input.value;
                if (monsterId) {
                    const file = videoQueue.find(f => f.name === fileName);
                    if (file) {
                        videos.push({ file, monster_id: monsterId });
                    }
                }
            });
            
            if (videos.length === 0) {
                alert('Please add videos and specify monster IDs');
                return;
            }
            
            // Show progress
            document.getElementById('videoProgress').classList.add('active');
            
            for (let i = 0; i < videos.length; i++) {
                const { file, monster_id } = videos[i];
                const formData = new FormData();
                formData.append('video', file);
                formData.append('monster_id', monster_id);
                formData.append('pack_name', pack);
                
                try {
                    const response = await fetch('/api/toolkit/process-video', {
                        method: 'POST',
                        body: formData
                    });
                    
                    const result = await response.json();
                    if (result.success) {
                        addLog('videoLog', `Processed ${monster_id}: ${result.compression_ratio}% compression`, 'success');
                    } else {
                        addLog('videoLog', `Failed ${monster_id}: ${result.error}`, 'error');
                    }
                    
                    // Update progress
                    const percent = ((i + 1) / videos.length) * 100;
                    document.getElementById('videoProgressFill').style.width = `${percent}%`;
                    document.getElementById('videoProgressFill').textContent = `${Math.round(percent)}%`;
                    document.getElementById('videoStatus').textContent = `Processing ${i+1} of ${videos.length}`;
                } catch (error) {
                    addLog('videoLog', `Error processing ${monster_id}: ${error}`, 'error');
                }
            }
            
            document.getElementById('videoProgress').classList.remove('active');
            document.getElementById('videoList').innerHTML = '';
            videoQueue = [];
        }
        
        // Settings
        async function saveSettings() {
            const activePack = document.getElementById('activePackSetting').value;
            const apiKey = document.getElementById('apiKey').value;
            
            try {
                const response = await fetch('/api/toolkit/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ active_pack: activePack, api_key: apiKey })
                });
                
                const result = await response.json();
                if (result.success) {
                    alert('Settings saved successfully');
                } else {
                    alert(`Failed to save settings: ${result.error}`);
                }
            } catch (error) {
                console.error('Failed to save settings:', error);
            }
        }
        
        // Socket handlers
        function setupSocketHandlers() {
            socket.on('connect', () => {
                console.log('Socket connected successfully');
                document.getElementById('connectionStatus')?.classList.add('online');
            });
            
            socket.on('disconnect', () => {
                document.getElementById('connectionStatus')?.classList.remove('online');
            });
            
            socket.on('generation_progress', (data) => {
                const percent = (data.current / data.total) * 100;
                document.getElementById('genProgressFill').style.width = `${percent}%`;
                document.getElementById('genProgressFill').textContent = `${Math.round(percent)}%`;
                document.getElementById('genStatus').textContent = `Generating ${data.monster} (${data.current}/${data.total})`;
            });
            
            socket.on('generation_complete', (data) => {
                document.getElementById('genProgress').style.display = 'none'; // Use style.display
                addLog('genLog', `Generation complete: ${data.successful.length} successful, ${data.failed.length} failed`, 'info');
                
                // Only refresh the monster list, don't reload packs (which would reset the dropdown)
                loadMonsters();
                
                // Optionally update pack statistics without resetting selections
                // loadPacks() was causing the target pack to reset
            });
            
            // Bestiary update events
            socket.on('bestiary_update_progress', (data) => {
                console.log('[Bestiary Update Progress]', data);
                const progressText = document.getElementById('bestiary-progress-text');
                if (progressText) {
                    progressText.textContent = data.message;
                }
            });
            
            socket.on('bestiary_update_complete', (data) => {
                console.log('[Bestiary Update Complete]', data);
                const progressDiv = document.getElementById('bestiary-progress');
                if (progressDiv) {
                    progressDiv.innerHTML = `
                        <h4 style="color: #4CAF50; margin: 0 0 10px 0;"> Bestiary Updated!</h4>
                        <div>${data.message}</div>
                        <button onclick="this.parentElement.remove()" style="margin-top: 10px; padding: 5px 10px; background: #444; border: none; color: white; cursor: pointer; border-radius: 3px;">Close</button>
                    `;
                    // Auto-remove after 10 seconds
                    setTimeout(() => {
                        const div = document.getElementById('bestiary-progress');
                        if (div) div.remove();
                    }, 10000);
                }
                
                // Refresh the monster list if in missing bestiary mode
                if (document.getElementById('filter-missing-bestiary') && document.getElementById('filter-missing-bestiary').checked) {
                    crossReferenceModuleMonsters();
                }
            });
            
            // NPC Management events
            socket.on('npc_description_progress', (data) => {
                console.log('[NPC Description Progress]', data);
                
                // Find the status box elements
                const statusBox = document.getElementById('npc-description-status-box');
                const statusTitle = document.getElementById('npc-status-title');
                const statusMessage = document.getElementById('npc-status-message');

                if (!statusBox || statusBox.style.display === 'none') {
                    // Don't do anything if the box isn't visible
                    return;
                }

                if (data.status === 'success') {
                    // Update the message with the current progress
                    statusMessage.textContent = `(${data.current}/${data.total}) Generated description for: ${data.npc_name}`;
                    
                    // Check if the process is complete
                    if (data.current === data.total) {
                        statusBox.classList.remove('error');
                        statusBox.classList.add('success');
                        statusTitle.textContent = ' Process Complete';
                        statusMessage.textContent = `Successfully processed all ${data.total} selected NPCs.`;
                        
                        // Auto-hide the box after 5 seconds
                        setTimeout(() => {
                            statusBox.style.display = 'none';
                        }, 5000);
                    }
                } else { // Handle errors
                    statusBox.classList.add('error');
                    statusTitle.textContent = ' An Error Occurred';
                    statusMessage.textContent = `Failed on ${data.npc_name}: ${data.error || 'Unknown error'}`;
                    // Don't auto-hide on error, let the user close it
                }

                // Keep the original log and progress bar updates
                addLog('npcGenLog', `Generating description for ${data.npc_name} (${data.current}/${data.total})`, 
                       data.status === 'success' ? 'success' : 'error');
                       
                // Update NPC progress bar
                const percent = (data.current / data.total) * 100;
                document.getElementById('npcGenProgressFill').style.width = `${percent}%`;
                document.getElementById('npcGenProgressFill').textContent = `${Math.round(percent)}%`;
                document.getElementById('npcGenStatus').textContent = `Generating description for ${data.npc_name} (${data.current}/${data.total})`;
                document.getElementById('npcGenProgress').style.display = 'block';
            });
            
            socket.on('npc_portrait_progress', (data) => {
                console.log('[NPC Portrait Progress]', data);
                addLog('npcGenLog', `Generating portrait for ${data.npc_name} (${data.current}/${data.total})`, 
                       data.status === 'success' ? 'success' : 'error');
                       
                // Update NPC progress bar
                const percent = (data.current / data.total) * 100;
                document.getElementById('npcGenProgressFill').style.width = `${percent}%`;
                document.getElementById('npcGenProgressFill').textContent = `${Math.round(percent)}%`;
                document.getElementById('npcGenStatus').textContent = `Generating portrait for ${data.npc_name} (${data.current}/${data.total})`;
                document.getElementById('npcGenProgress').style.display = 'block';
                       
                // Update thumbnail if successful
                if (data.status === 'success') {
                    const packName = document.getElementById('npcPackSelect').value;
                    // Refresh the thumbnail for this NPC
                    const npcId = data.npc_name.toLowerCase().replace(/\s+/g, '_').replace(/'/g, '').replace(/-/g, '_');
                    loadNpcThumbnail(npcId, packName);
                }
            });
            
            socket.on('npc_generation_complete', (data) => {
                console.log('[NPC Generation Complete]', data);
                
                // Hide NPC progress bar
                document.getElementById('npcGenProgress').style.display = 'none';
                
                const successful = data.successful || [];
                const failed = data.failed || [];
                
                if (successful.length > 0) {
                    addLog('npcGenLog', `Successfully generated ${successful.length} portrait(s)!`, 'success');
                    successful.forEach(item => {
                        addLog('npcGenLog', `[OK] ${item.npc_name} portrait saved`, 'success');
                    });
                }
                
                if (failed.length > 0) {
                    addLog('npcGenLog', `Failed to generate ${failed.length} portrait(s)`, 'error');
                    failed.forEach(item => {
                        addLog('npcGenLog', `[ERROR] ${item.npc_id}: ${item.error}`, 'error');
                    });
                }
                
                // Reload the NPC list to show updated thumbnails
                setTimeout(() => loadNpcsForModule(), 2000);
            });
            
            socket.on('npc_portrait_complete', (data) => {
                console.log('[NPC Portrait Complete]', data);
                addLog('genLog', `Portrait generation complete for ${data.count} NPCs in pack '${data.pack_name}'`, 'success');
                
                // Hide progress bar
                document.getElementById('genProgress').style.display = 'none';
                document.getElementById('genProgressFill').style.width = '0%';
                document.getElementById('genProgressFill').textContent = '0%';
                document.getElementById('genStatus').textContent = 'Complete';
                
                // Refresh the NPC list to show updated portraits
                loadNpcsForModule();
            });
            
            socket.on('bestiary_update_error', (data) => {
                console.error('[Bestiary Update Error]', data);
                const progressDiv = document.getElementById('bestiary-progress');
                if (progressDiv) {
                    progressDiv.innerHTML = `
                        <h4 style="color: #f44336; margin: 0 0 10px 0;"> Update Failed</h4>
                        <div style="color: #ff9999;">${data.error}</div>
                        <button onclick="this.parentElement.remove()" style="margin-top: 10px; padding: 5px 10px; background: #444; border: none; color: white; cursor: pointer; border-radius: 3px;">Close</button>
                    `;
                }
                alert(`Bestiary update failed: ${data.error}`);
            });
            
            socket.on('video_progress', (data) => {
                const percent = (data.current / data.total) * 100;
                document.getElementById('videoProgressFill').style.width = `${percent}%`;
                document.getElementById('videoProgressFill').textContent = `${Math.round(percent)}%`;
                document.getElementById('videoStatus').textContent = `Processing ${data.monster} (${data.current}/${data.total})`;
            });
        }
        
        // Utilities
        function addLog(containerId, message, type = 'info') {
            const container = document.getElementById(containerId);
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            container.appendChild(entry);
            container.scrollTop = container.scrollHeight;
        }
        
        // Media Popup Functions
        function showMediaPopup(event) {
            console.log('showMediaPopup called');
            const thumbContainer = event.currentTarget;
            const monsterName = thumbContainer.closest('.monster-item').querySelector('.monster-label span').textContent;
            
            const modal = document.getElementById('media-modal');
            const modalBody = document.getElementById('media-modal-body');
            const modalTitle = document.getElementById('media-modal-title');

            if (!modal) {
                console.error('Media modal not found!');
                return;
            }

            modalTitle.textContent = monsterName;
            modalBody.innerHTML = ''; // Clear previous content

            if (thumbContainer.dataset.videoSrc) {
                console.log('Showing video:', thumbContainer.dataset.videoSrc);
                // If video exists, show it with cache busting
                const video = document.createElement('video');
                video.src = thumbContainer.dataset.videoSrc + '?t=' + new Date().getTime();
                video.controls = true;
                video.autoplay = true;
                video.loop = true;
                modalBody.appendChild(video);
            } else if (thumbContainer.dataset.imageSrc) {
                console.log('Showing image:', thumbContainer.dataset.imageSrc);
                // Show the full-size image with cache busting
                const img = document.createElement('img');
                img.src = thumbContainer.dataset.imageSrc + '?t=' + new Date().getTime();
                modalBody.appendChild(img);
            } else if (thumbContainer.dataset.thumbSrc) {
                console.log('Showing thumbnail:', thumbContainer.dataset.thumbSrc);
                // Fallback to thumbnail if full image not available
                const img = document.createElement('img');
                img.src = thumbContainer.dataset.thumbSrc;
                modalBody.appendChild(img);
            }
            
            // Actually show the modal!
            modal.classList.add('active');
        }

        function closeMediaPopup() {
            const modal = document.getElementById('media-modal');
            const modalBody = document.getElementById('media-modal-body');
            modal.classList.remove('active');
            // Clear the content to stop any videos from playing in the background
            modalBody.innerHTML = '';
        }

        // Pack Overview Tab Functions
        async function loadPackOverview() {
            try {
                // Load active pack info
                const packs = availablePacks || [];
                activePack = packs.find(p => p.is_active) || packs[0];
                
                if (activePack) {
                    // Update active pack display
                    document.getElementById('activePackName').textContent = activePack.display_name || activePack.name;
                    document.getElementById('activePackDescription').textContent = activePack.description || `${activePack.style || 'Custom'} style monster pack`;
                    
                    // Use counts from pack manifest
                    const monsterCount = activePack.total_monsters || Object.keys(activePack.monsters || {}).length || 0;
                    const videoCount = activePack.total_videos || 0;
                    
                    // Update stats
                    document.getElementById('activePackMonsters').textContent = monsterCount;
                    document.getElementById('activePackVideos').textContent = videoCount;
                    
                    // Load monster thumbnails
                    await loadMonsterThumbnails(activePack);
                }
            } catch (error) {
                console.error('Failed to load pack overview:', error);
            }
        }

        async function loadMonsterThumbnails(pack) {
            const withVideos = document.getElementById('monstersWithVideos');
            const withoutVideos = document.getElementById('monstersWithoutVideos');
            withVideos.innerHTML = '';
            withoutVideos.innerHTML = '';
            
            if (!pack || !pack.monsters) return;
            
            Object.entries(pack.monsters).forEach(([monsterName, monsterData]) => {
                const hasVideo = monsterData.video_path && monsterData.video_path !== '';
                const container = hasVideo ? withVideos : withoutVideos;
                
                const thumbnail = document.createElement('div');
                thumbnail.className = 'monster-thumbnail';
                
                // Create image element
                if (monsterData.image_path) {
                    const img = document.createElement('img');
                    img.src = `/static/${monsterData.image_path}`;
                    img.alt = monsterName;
                    thumbnail.appendChild(img);
                }
                
                // Create video element if available
                if (hasVideo) {
                    const video = document.createElement('video');
                    video.src = `/static/${monsterData.video_path}`;
                    video.muted = true;
                    video.loop = true;
                    video.onmouseenter = () => video.play();
                    video.onmouseleave = () => video.pause();
                    thumbnail.appendChild(video);
                } else {
                    // Add no-video tag
                    const noVideoTag = document.createElement('div');
                    noVideoTag.className = 'no-video-tag';
                    noVideoTag.textContent = 'No Video';
                    thumbnail.appendChild(noVideoTag);
                }
                
                // Add monster name
                const nameLabel = document.createElement('div');
                nameLabel.className = 'monster-name';
                nameLabel.textContent = monsterName;
                thumbnail.appendChild(nameLabel);
                
                container.appendChild(thumbnail);
            });
        }

        // Model warning for GPT-Image
        function checkModelWarning() {
            const modelSelect = document.getElementById('genModel');
            const warning = document.getElementById('modelWarning');
            
            if (modelSelect.value === 'gpt-image-1') {
                warning.style.display = 'block';
            } else {
                warning.style.display = 'none';
            }
        }

        // Update pack selectors to include overview refresh
        const originalUpdatePackSelectors = updatePackSelectors;
        updatePackSelectors = function() {
            originalUpdatePackSelectors();
            if (currentTab === 'overview') {
                loadPackOverview();
            }
        };
        
        // New functions for pack creation and prompt management
        function toggleNewPackFields() {
            const checkbox = document.getElementById('createNewPack');
            const fields = document.getElementById('newPackFields');
            const packSelect = document.getElementById('genPack');
            
            if (checkbox.checked) {
                fields.classList.add('enabled');
                packSelect.disabled = true; // Disable pack selection when creating new
            } else {
                fields.classList.remove('enabled');
                packSelect.disabled = false; // Re-enable pack selection
            }
        }
        
        // Handle monster selection change - now supports multi-selection
        function handleMonsterSelection(monsterId) {
            const checkbox = document.querySelector(`input[value="${monsterId}"]`);
            const selectedMonsters = Array.from(document.querySelectorAll('input[name="monster"]:checked'));
            
            // Update the button and status text
            updateSelectionStatus();
            
            // For description, show the most recently selected monster
            if (checkbox && checkbox.checked) {
                loadMonsterDescription(monsterId);
            } else if (selectedMonsters.length > 0) {
                // If this was unchecked but others remain, show the first selected
                loadMonsterDescription(selectedMonsters[0].value);
            } else {
                // No monsters selected
                document.getElementById('monsterDescriptionBox').value = 'Select a monster from the list to see its description...';
                document.getElementById('selectedMonsterName').textContent = 'No monster selected';
            }
        }
        
        // Update the status to show how many monsters are selected
        function updateSelectionStatus() {
            const selectedMonsters = Array.from(document.querySelectorAll('input[name="monster"]:checked'));
            const generateBtn = document.querySelector('button[onclick="startGeneration()"]');
            const addToBestiaryBtn = document.getElementById('add-to-bestiary-btn');
            
            // Update Generate Button Text
            if (generateBtn && generateBtn.style.display !== 'none') {
                if (selectedMonsters.length === 0) {
                    generateBtn.textContent = 'Generate Selected Images to Current Pack';
                } else if (selectedMonsters.length === 1) {
                    generateBtn.textContent = 'Generate 1 Selected Image to Current Pack';
                } else {
                    generateBtn.textContent = `Generate ${selectedMonsters.length} Selected Images to Current Pack`;
                }
            }
            
            // Update Add to Bestiary Button Text
            if (addToBestiaryBtn && addToBestiaryBtn.style.display !== 'none') {
                if (selectedMonsters.length === 0) {
                    addToBestiaryBtn.textContent = 'Add to Bestiary';
                } else {
                    addToBestiaryBtn.textContent = `Add ${selectedMonsters.length} to Bestiary`;
                }
            }
        }
        
        // Apply legend filters to show/hide monsters based on selected categories (AND logic)
        function applyLegendFilters() {
            const filters = {
                bestiary: document.getElementById('filter-bestiary').checked,
                packOnly: document.getElementById('filter-pack-only').checked,
                missing: document.getElementById('filter-missing').checked,
                inModule: document.getElementById('filter-in-module').checked,
            };

            const isAnyFilterActive = Object.values(filters).some(v => v === true);
            const monsterItems = document.querySelectorAll('.monster-item');

            monsterItems.forEach(item => {
                if (!isAnyFilterActive) {
                    // If no filters are active, show all items
                    item.style.display = 'flex';
                    return;
                }

                // Start by assuming the item should be shown
                let shouldShow = true; 
                
                // Check each active filter. If the item fails ANY check, it gets hidden (AND logic)
                if (filters.bestiary && !item.classList.contains('monster-bestiary')) {
                    shouldShow = false;
                }
                if (filters.packOnly && !item.classList.contains('monster-pack-only')) {
                    shouldShow = false;
                }
                if (filters.missing && !item.classList.contains('monster-bestiary-only')) {
                    shouldShow = false;
                }
                if (filters.inModule && !item.classList.contains('monster-in-module')) {
                    shouldShow = false;
                }

                // Set the final display style based on the AND logic checks
                item.style.display = shouldShow ? 'flex' : 'none';
            });
        }
        
        // Toggle special mode for showing only missing bestiary entries
        function toggleBestiaryMissingMode() {
            const isMissingMode = document.getElementById('filter-missing-bestiary').checked;
            const legendFilters = document.querySelectorAll('.legend-filter');
            const monsterItems = document.querySelectorAll('.monster-item');
            const generateBtn = document.querySelector('button[onclick="startGeneration()"]');
            const addToBestiaryBtn = document.getElementById('add-to-bestiary-btn');

            if (isMissingMode) {
                // --- ENTERING MISSING MODE ---
                // 1. Disable and uncheck other filters
                legendFilters.forEach(filter => {
                    filter.checked = false;
                    filter.disabled = true;
                });

                // 2. Show only placeholder monsters and enable their checkboxes
                monsterItems.forEach(item => {
                    if (item.classList.contains('placeholder-monster')) {
                        item.style.display = 'flex';
                        const checkbox = item.querySelector('input[name="monster"]');
                        if (checkbox) checkbox.disabled = false;
                    } else {
                        item.style.display = 'none';
                    }
                });

                // 3. Toggle button visibility
                generateBtn.style.display = 'none';
                addToBestiaryBtn.style.display = 'inline-block';

            } else {
                // --- EXITING MISSING MODE ---
                // 1. Re-enable other filters
                legendFilters.forEach(filter => {
                    filter.disabled = false;
                });

                // 2. Disable placeholder checkboxes and re-apply normal filters
                monsterItems.forEach(item => {
                    if (item.classList.contains('placeholder-monster')) {
                        const checkbox = item.querySelector('input[name="monster"]');
                        if (checkbox) checkbox.disabled = true;
                    }
                });
                applyLegendFilters(); // This will restore the correct view

                // 3. Toggle button visibility
                generateBtn.style.display = 'inline-block';
                addToBestiaryBtn.style.display = 'none';
            }
            updateSelectionStatus(); // Update button text/state
        }
        
        // Function to add selected monsters to bestiary
        async function addSelectedToBestiary() {
            const selectedCheckboxes = document.querySelectorAll('.monster-item.placeholder-monster input[name="monster"]:checked');
            const selectedMonsters = Array.from(selectedCheckboxes).map(cb => {
                // Get the monster name from the label text
                const label = cb.closest('label');
                const span = label.querySelector('span');
                return span ? span.textContent : cb.value;
            });
            
            if (selectedMonsters.length === 0) {
                alert('Please select one or more monsters that are missing from the bestiary.');
                return;
            }
            
            // Get the current module name
            const moduleName = document.getElementById('genModule').value;
            if (!moduleName) {
                alert('Please select a module first.');
                return;
            }
            
            // Confirm with user
            const confirmMsg = `This will use GPT-4o-mini to generate descriptions for the following ${selectedMonsters.length} monster(s):\n\n- ${selectedMonsters.join('\n- ')}\n\nProceed?`;
            if (!confirm(confirmMsg)) {
                return;
            }
            
            // Disable button and show progress
            const button = document.getElementById('add-to-bestiary-btn');
            button.disabled = true;
            button.textContent = 'Processing...';
            
            try {
                const response = await fetch('/api/toolkit/add-to-bestiary', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        module_name: moduleName,
                        monster_names: selectedMonsters
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Show initial message
                    console.log('[Bestiary Update] Process started for:', selectedMonsters);
                    
                    // Add a progress div if it doesn't exist
                    let progressDiv = document.getElementById('bestiary-progress');
                    if (!progressDiv) {
                        progressDiv = document.createElement('div');
                        progressDiv.id = 'bestiary-progress';
                        progressDiv.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #2c2c2c; border: 2px solid #FFA500; padding: 15px; border-radius: 5px; z-index: 10000; min-width: 300px;';
                        progressDiv.innerHTML = '<h4 style="color: #FFA500; margin: 0 0 10px 0;">Bestiary Update</h4><div id="bestiary-progress-text">Starting process...</div>';
                        document.body.appendChild(progressDiv);
                    }
                    
                    // Update progress text
                    document.getElementById('bestiary-progress-text').textContent = `Processing ${selectedMonsters.length} monsters...`;
                } else {
                    alert(`Error: ${result.error}`);
                }
            } catch (error) {
                alert(`Failed to start bestiary update: ${error}`);
            } finally {
                // Re-enable button
                button.disabled = false;
                updateSelectionStatus();
            }
        }
        
        // Load monster description when selected
        function loadMonsterDescription(monsterId) {
            const descriptionBox = document.getElementById('monsterDescriptionBox');
            const monsterNameLabel = document.getElementById('selectedMonsterName');
            
            fetch(`/toolkit/get_monster_description/${monsterId}`)
            .then(response => response.json())
            .then(data => {
                if (data.description) {
                    descriptionBox.value = data.description;
                    monsterNameLabel.textContent = `Selected: ${data.name || monsterId}`;
                } else {
                    descriptionBox.value = 'No description available for this monster.';
                    monsterNameLabel.textContent = `Selected: ${monsterId}`;
                }
            })
            .catch(error => {
                console.error('Error loading monster description:', error);
                descriptionBox.value = 'Error loading description.';
            });
        }
        
        // Load and display style prompt
        function loadStylePrompt() {
            const styleSelect = document.getElementById('genStyle');
            const stylePromptBox = document.getElementById('stylePromptBox');
            
            fetch(`/toolkit/get_style_prompt/${styleSelect.value}`)
            .then(response => response.json())
            .then(data => {
                if (data.prompt) {
                    stylePromptBox.value = data.prompt;
                } else {
                    stylePromptBox.value = '';
                }
            })
            .catch(error => {
                console.error('Error loading style prompt:', error);
                stylePromptBox.value = '';
            });
        }
        
        // Save the edited style prompt back to the current style
        function saveStylePrompt() {
            const styleSelect = document.getElementById('genStyle');
            const stylePrompt = document.getElementById('stylePromptBox').value;
            
            if (!stylePrompt) {
                alert('Please enter a style prompt');
                return;
            }
            
            fetch('/toolkit/update_style_prompt', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    style_id: styleSelect.value,
                    prompt: stylePrompt
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Style prompt updated successfully!');
                } else {
                    alert('Failed to update style: ' + (data.error || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Error updating style:', error);
                alert('Failed to update style prompt');
            });
        }
        
        // Save as a new custom style
        function saveAsNewStyle() {
            const styleName = document.getElementById('newStyleName').value;
            const stylePrompt = document.getElementById('stylePromptBox').value;
            
            if (!styleName) {
                alert('Please enter a name for the custom style');
                return;
            }
            
            if (!stylePrompt) {
                alert('Please enter a prompt for the custom style');
                return;
            }
            
            fetch('/toolkit/save_style_template', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: styleName,
                    prompt: stylePrompt
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Custom style saved successfully!');
                    document.getElementById('newStyleName').value = '';
                    // Reload style dropdown to include new style
                    loadStyles();
                } else {
                    alert('Failed to save style: ' + (data.error || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Error saving style:', error);
                alert('Failed to save custom style');
            });
        }
        
        // Save monster description
        function saveMonsterDescription() {
            const selectedMonsters = Array.from(document.querySelectorAll('input[name="monster"]:checked'));
            if (selectedMonsters.length === 0) {
                alert('Please select a monster first');
                return;
            }
            
            const monsterId = selectedMonsters[0].value;
            const description = document.getElementById('monsterDescriptionBox').value;
            
            fetch('/toolkit/update_monster_description', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    monster_id: monsterId,
                    description: description
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Monster description updated!');
                } else {
                    alert('Failed to update description: ' + (data.error || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Error updating description:', error);
                alert('Failed to update monster description');
            });
        }
        
        function loadStyles() {
            fetch('/toolkit/get_styles')
            .then(response => response.json())
            .then(data => {
                console.log('Styles received:', data);
                const styleSelect = document.getElementById('genStyle');
                const npcStyleSelect = document.getElementById('npcStyleSelect');
                
                // Clear current options
                styleSelect.innerHTML = '';
                if (npcStyleSelect) {
                    npcStyleSelect.innerHTML = '';
                }
                
                // Add builtin styles
                if (data.builtin) {
                    Object.entries(data.builtin).forEach(([id, style]) => {
                        // Monster style dropdown
                        const option = new Option(style.name, id);
                        styleSelect.appendChild(option);
                        
                        // NPC style dropdown
                        if (npcStyleSelect) {
                            const npcOption = new Option(style.name, id);
                            npcStyleSelect.appendChild(npcOption);
                        }
                    });
                }
                
                // Add custom styles if any
                if (data.custom && Object.keys(data.custom).length > 0) {
                    const separator = new Option('--- Custom Styles ---', '', true, false);
                    separator.disabled = true;
                    styleSelect.appendChild(separator);
                    
                    if (npcStyleSelect) {
                        const npcSeparator = new Option('--- Custom Styles ---', '', true, false);
                        npcSeparator.disabled = true;
                        npcStyleSelect.appendChild(npcSeparator);
                    }
                    
                    Object.entries(data.custom).forEach(([id, style]) => {
                        // Monster style dropdown
                        const option = new Option(style.name + ' (Custom)', id);
                        styleSelect.appendChild(option);
                        
                        // NPC style dropdown
                        if (npcStyleSelect) {
                            const npcOption = new Option(style.name + ' (Custom)', id);
                            npcStyleSelect.appendChild(npcOption);
                        }
                    });
                }
                
                // Load prompt for selected style
                loadStylePrompt();
                if (npcStyleSelect) {
                    loadNpcStylePrompt();
                }
            })
            .catch(error => {
                console.error('Error loading styles:', error);
            });
        }
        
        // Monster edit functions
        function editMonster(monsterId) {
            // TODO: Implement monster editing
            alert('Monster editing coming soon!');
        }
        
        function regenerateMonster(monsterId) {
            const packSelect = document.getElementById('genPack');
            const styleSelect = document.getElementById('genStyle');
            const modelSelect = document.getElementById('genModel');
            
            if (packSelect.value === '__new__') {
                alert('Please select or create a pack first');
                return;
            }
            
            // TODO: Implement monster regeneration
            alert('Monster regeneration coming soon!');
        }
        
        function deleteMonster(monsterId) {
            if (!confirm(`Are you sure you want to delete ${monsterId}?`)) {
                return;
            }
            
            // TODO: Implement monster deletion
            alert('Monster deletion coming soon!');
        }
        
        // Load styles and initialize on page load
        // Removed duplicate DOMContentLoaded listener - already handled above

        // === NPC MANAGEMENT & GENERATOR FUNCTIONS ===
        
        // Populates the module dropdown on the NPC tab
        async function loadNpcModules() {
            try {
                const response = await fetch('/api/toolkit/modules');
                const modules = await response.json();
                const select = document.getElementById('npcModuleSelect');
                if (!select) return; // Tab might not be active
                
                select.innerHTML = '<option value="">-- Select a Module --</option>'; 
                
                modules.forEach(module => {
                    const option = document.createElement('option');
                    option.value = module.moduleName;
                    option.textContent = module.moduleName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Failed to load NPC modules:', error);
            }
        }

        // Populates the pack dropdown on the NPC tab
        function loadNpcPacks() {
            const select = document.getElementById('npcPackSelect');
            if (!select) return;
            const activePackName = availablePacks.find(p => p.is_active)?.name;
            select.innerHTML = '';
            availablePacks.forEach(pack => {
                const option = document.createElement('option');
                option.value = pack.name;
                option.textContent = pack.display_name || pack.name;
                if (pack.name === activePackName) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
        }

        // Main function to scan a module and display its NPCs
        async function loadNpcsForModule() {
            const moduleName = document.getElementById('npcModuleSelect').value;
            const packName = document.getElementById('npcPackSelect').value;
            const includeLocal = document.getElementById('filter-include-local').checked; // Get the toggle state
            const grid = document.getElementById('npcGrid');

            if (!moduleName) {
                grid.innerHTML = '<div class="loading">Please select a module to scan for NPCs.</div>';
                return;
            }
            
            if (!packName) {
                grid.innerHTML = '<div class="loading">Please select a target pack.</div>';
                return;
            }
            
            grid.innerHTML = '<div class="loading">Scanning for NPCs...</div>';

            try {
                // Append the new 'include_local' parameter to the API call
                const response = await fetch(`/api/toolkit/modules/${moduleName}/npcs?pack=${packName}&include_local=${includeLocal}`);
                const npcs = await response.json();
                renderNpcs(npcs);
            } catch (error) {
                console.error('Failed to load NPCs for module:', error);
                grid.innerHTML = '<div class="loading" style="color: #f44336;">Error loading NPCs.</div>';
            }
        }

        // Renders the list of NPCs into the grid
        function renderNpcs(npcs) {
            const grid = document.getElementById('npcGrid');
            grid.innerHTML = '';
            let existsCount = 0;
            let missingCount = 0;
            let localCount = 0;

            if (!npcs || npcs.length === 0) {
                grid.innerHTML = '<div class="loading">No NPCs found in this module.</div>';
                // Reset counts to 0
                document.getElementById('npc-count-exists').textContent = `(0)`;
                document.getElementById('npc-count-missing').textContent = `(0)`;
                document.getElementById('npc-count-local').textContent = `(0)`;
                return;
            }

            npcs.forEach(npc => {
                const item = document.createElement('div');
                const statusClass = npc.has_portrait ? 'has-portrait' : 'missing-portrait';
                item.className = `monster-item npc-item ${statusClass}`;
                
                // Update counters
                if (npc.has_portrait) existsCount++; else missingCount++;
                if (npc.is_local) {
                    item.classList.add('is-local');
                    localCount++;
                }

                item.innerHTML = `
                    <label class="monster-label">
                        <input type="checkbox" value="${npc.name}" name="npc-select" onchange="loadNpcDescription('${npc.name.replace(/'/g, "\\'")}'); updateNpcSelectionStatus()" data-npc-id="${npc.id}">
                        <span>${npc.name}</span>
                    </label>
                    <div class="npc-thumbnail-preview" id="thumb-npc-${npc.id}">
                        <!-- Thumbnail will be loaded here -->
                    </div>
                `;
                grid.appendChild(item);
                
                // Load thumbnail if it exists in either the pack or local files
                if (npc.has_portrait || npc.is_local) {
                    loadNpcThumbnail(npc.id, npc.pack_name, npc.is_local);
                } else {
                    const thumbContainer = document.getElementById(`thumb-npc-${npc.id}`);
                    if(thumbContainer) thumbContainer.innerHTML = '<div class="no-image-placeholder">?</div>';
                }
            });

            // Update all legend counters
            document.getElementById('npc-count-exists').textContent = `(${existsCount})`;
            document.getElementById('npc-count-missing').textContent = `(${missingCount})`;
            document.getElementById('npc-count-local').textContent = `(${localCount})`;
        }

        // Loads a single NPC thumbnail with click handling for full preview
        function loadNpcThumbnail(npcId, packName, isLocal = false) {
            const thumbContainer = document.getElementById(`thumb-npc-${npcId}`);
            if (!thumbContainer) return;
            
            // Try pack first, then fall back to local game files if isLocal is true
            const portraitUrl = `/api/toolkit/packs/${packName}/npcs/${npcId}/thumbnail?v=${new Date().getTime()}`; // Cache bust
            const fullImageUrl = `/api/toolkit/packs/${packName}/npcs/${npcId}/image`;
            const videoUrl = `/api/toolkit/packs/${packName}/npcs/${npcId}/video`;

            const img = new Image();
            img.onload = () => {
                thumbContainer.innerHTML = '';
                thumbContainer.appendChild(img);
                
                // Store URLs for popup use
                thumbContainer.dataset.thumbSrc = `/api/toolkit/packs/${packName}/npcs/${npcId}/thumbnail`;
                thumbContainer.dataset.imageSrc = fullImageUrl;
                thumbContainer.dataset.npcId = npcId;
                thumbContainer.dataset.packName = packName;
                
                // Make the container clickable
                thumbContainer.style.cursor = 'pointer';
                
                // Check if video exists
                fetch(videoUrl, { method: 'HEAD' })
                    .then(res => {
                        if (res.ok) {
                            console.log(`Video found for NPC ${npcId}`);
                            // Video exists, add indicator
                            thumbContainer.dataset.videoSrc = videoUrl;
                            const indicator = document.createElement('div');
                            indicator.className = 'video-indicator';
                            indicator.innerHTML = '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>';
                            thumbContainer.appendChild(indicator);
                        } else {
                            console.log(`No video for NPC ${npcId}`);
                        }
                        // Add click listener regardless of video existence
                        thumbContainer.addEventListener('click', showNpcMediaPopup);
                    })
                    .catch((err) => {
                        console.log(`Error checking video for NPC ${npcId}:`, err);
                        // If fetch fails, still add click listener for image
                        thumbContainer.addEventListener('click', showNpcMediaPopup);
                    });
            };
            img.onerror = () => {
                // If pack load fails and isLocal is true, try loading from game folder
                if (isLocal) {
                    // Try loading directly from the game's NPC media folder
                    const gameThumbUrl = `/static/media/npcs/${npcId}_thumb.jpg`;
                    const gameImg = new Image();
                    gameImg.onload = () => {
                        thumbContainer.innerHTML = '';
                        thumbContainer.appendChild(gameImg);
                        thumbContainer.style.cursor = 'pointer';
                        thumbContainer.addEventListener('click', showNpcMediaPopup);
                    };
                    gameImg.onerror = () => {
                        // Try non-thumbnail version
                        const gameFullUrl = `/static/media/npcs/${npcId}.jpg`;
                        const gameFull = new Image();
                        gameFull.onload = () => {
                            thumbContainer.innerHTML = '';
                            thumbContainer.appendChild(gameFull);
                            thumbContainer.style.cursor = 'pointer';
                            thumbContainer.addEventListener('click', showNpcMediaPopup);
                        };
                        gameFull.onerror = () => {
                            thumbContainer.innerHTML = '<div class="no-image-placeholder">?</div>';
                        };
                        gameFull.src = gameFullUrl;
                    };
                    gameImg.src = gameThumbUrl;
                } else {
                    thumbContainer.innerHTML = '<div class="no-image-placeholder">?</div>';
                    const npcItem = thumbContainer.closest('.npc-item');
                    if (npcItem) npcItem.dataset.missingImage = "true";
                }
            };
            img.src = portraitUrl;
        }

        // Show NPC media popup (full image or video)
        function showNpcMediaPopup(event) {
            console.log('showNpcMediaPopup called');
            const thumbContainer = event.currentTarget;
            const npcName = thumbContainer.closest('.npc-item').querySelector('.monster-label span').textContent;
            
            const modal = document.getElementById('media-modal');
            const modalBody = document.getElementById('media-modal-body');
            const modalTitle = document.getElementById('media-modal-title');

            if (!modal) {
                console.error('Media modal not found!');
                return;
            }

            modalTitle.textContent = npcName;
            modalBody.innerHTML = ''; // Clear previous content

            if (thumbContainer.dataset.videoSrc) {
                console.log('Showing NPC video:', thumbContainer.dataset.videoSrc);
                // If video exists, show it with cache busting
                const video = document.createElement('video');
                video.src = thumbContainer.dataset.videoSrc + '?t=' + new Date().getTime();
                video.controls = true;
                video.autoplay = true;
                video.loop = true;
                modalBody.appendChild(video);
            } else if (thumbContainer.dataset.imageSrc) {
                console.log('Showing NPC image:', thumbContainer.dataset.imageSrc);
                // Show the full-size image with cache busting
                const img = document.createElement('img');
                img.src = thumbContainer.dataset.imageSrc + '?t=' + new Date().getTime();
                modalBody.appendChild(img);
            } else if (thumbContainer.dataset.thumbSrc) {
                console.log('Showing NPC thumbnail:', thumbContainer.dataset.thumbSrc);
                // Fallback to thumbnail if full image not available
                const img = document.createElement('img');
                img.src = thumbContainer.dataset.thumbSrc + '?t=' + new Date().getTime();
                modalBody.appendChild(img);
            }
            
            // Show the modal
            modal.classList.add('active');
        }

        // --- Description Handling ---
        let currentSelectedNpc = null;
        
        async function fetchNpcDescriptions() {
            const moduleName = document.getElementById('npcModuleSelect').value;
            if (!moduleName) {
                alert('Please select a module first.');
                return;
            }
            
            // Get only SELECTED NPC names from the grid
            const selectedNpcItems = document.querySelectorAll('.npc-item input[name="npc-select"]:checked');
            const npcs = Array.from(selectedNpcItems).map(input => ({
                name: input.value,
                id: input.dataset.npcId
            }));

            if (npcs.length === 0) {
                alert('Please select at least one NPC to fetch descriptions for.');
                return;
            }

            // Show and prepare the status box
            const statusBox = document.getElementById('npc-description-status-box');
            const statusTitle = document.getElementById('npc-status-title');
            const statusMessage = document.getElementById('npc-status-message');

            // Reset styles and content
            statusBox.classList.remove('success', 'error');
            statusTitle.textContent = 'Fetching Descriptions...';
            statusMessage.textContent = `Preparing to process ${npcs.length} NPC(s)...`;
            statusBox.style.display = 'block';

            addLog('genLog', `Requesting AI descriptions for ${npcs.length} selected NPCs in module '${moduleName}'...`, 'info');
            
            // Show progress bar for description fetching
            document.getElementById('genProgress').style.display = 'block';
            document.getElementById('genProgressFill').style.width = '0%';
            document.getElementById('genProgressFill').textContent = '0%';
            document.getElementById('genStatus').textContent = 'Fetching NPC descriptions...';
            
            try {
                const response = await fetch('/api/toolkit/npcs/fetch-descriptions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ module_name: moduleName, npcs: npcs })
                });
                const result = await response.json();
                if (result.success) {
                    addLog('genLog', 'AI description generation process started. Descriptions will appear as they are generated.', 'success');
                } else {
                    // If the initial request fails, show an error in the box
                    statusBox.classList.add('error');
                    statusTitle.textContent = 'Request Failed';
                    statusMessage.textContent = result.error || 'Could not start the process.';
                    addLog('genLog', `Error starting description generation: ${result.error}`, 'error');
                }
            } catch (error) {
                statusBox.classList.add('error');
                statusTitle.textContent = 'Network Error';
                statusMessage.textContent = 'Failed to communicate with the server.';
                addLog('genLog', `Failed to start description generation: ${error}`, 'error');
            }
        }

        async function loadNpcDescription(npcName) {
            const moduleName = document.getElementById('npcModuleSelect').value;
            const descriptionBox = document.getElementById('npcDescriptionBox');
            const npcInput = document.querySelector(`input[name="npc-select"][value="${npcName.replace(/'/g, "\\'")}"]`);
            const npcId = npcInput ? npcInput.dataset.npcId : npcName.toLowerCase().replace(/\s+/g, '_');
            
            currentSelectedNpc = { name: npcName, id: npcId };
            document.getElementById('selectedNpcName').textContent = `Selected: ${npcName}`;
            descriptionBox.value = 'Loading description...';

            try {
                const response = await fetch(`/api/toolkit/npcs/description?module=${moduleName}&npc_id=${npcId}`);
                const result = await response.json();
                descriptionBox.value = result.description || 'No description found. Click "Fetch Descriptions" to generate one with AI.';
            } catch (error) {
                descriptionBox.value = 'Error loading description.';
            }
        }

        async function saveNpcDescription() {
            const moduleName = document.getElementById('npcModuleSelect').value;
            if (!moduleName || !currentSelectedNpc) {
                alert('Please select a module and an NPC to save a description for.');
                return;
            }
            
            const description = document.getElementById('npcDescriptionBox').value;

            try {
                const response = await fetch('/api/toolkit/npcs/description', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        module_name: moduleName, 
                        npc_id: currentSelectedNpc.id,
                        npc_name: currentSelectedNpc.name,
                        description: description 
                    })
                });
                const result = await response.json();
                if (result.success) {
                    alert('Description saved successfully!');
                } else {
                    alert(`Error saving description: ${result.error}`);
                }
            } catch (error) {
                alert(`Failed to save description: ${error}`);
            }
        }

        // --- Selection & Generation ---
        function selectAllNpcs(selectAll = true) {
            document.querySelectorAll('.npc-item').forEach(item => {
                const checkbox = item.querySelector('input[name="npc-select"]');
                if (selectAll || item.classList.contains('missing-portrait')) {
                    checkbox.checked = true;
                } else {
                    checkbox.checked = false;
                }
            });
            updateNpcSelectionStatus();
        }

        function deselectAllNpcs() {
            document.querySelectorAll('input[name="npc-select"]').forEach(cb => cb.checked = false);
            updateNpcSelectionStatus();
        }
        
        // Update NPC selection status to show count on button
        function updateNpcSelectionStatus() {
            const selectedNpcs = Array.from(document.querySelectorAll('input[name="npc-select"]:checked'));
            const generateBtn = document.querySelector('button[onclick="startNpcGeneration()"]');
            
            if (generateBtn) {
                if (selectedNpcs.length === 0) {
                    generateBtn.textContent = 'Generate Selected Portraits';
                } else if (selectedNpcs.length === 1) {
                    generateBtn.textContent = 'Generate 1 Selected Portrait';
                } else {
                    generateBtn.textContent = `Generate ${selectedNpcs.length} Selected Portraits`;
                }
            }
        }

        // NPC Model Warning
        function checkNpcModelWarning() {
            const modelSelect = document.getElementById('npcModelSelect');
            const warning = document.getElementById('npcModelWarning');
            
            if (modelSelect.value === 'gpt-image-1') {
                warning.style.display = 'block';
            } else {
                warning.style.display = 'none';
            }
        }

        // NPC Style Management Functions
        function loadNpcStylePrompt() {
            const styleSelect = document.getElementById('npcStyleSelect');
            const stylePromptBox = document.getElementById('npcStylePromptBox');
            
            if (!styleSelect || !stylePromptBox) return;
            
            fetch(`/toolkit/get_style_prompt/${styleSelect.value}`)
            .then(response => response.json())
            .then(data => {
                if (data.prompt) {
                    stylePromptBox.value = data.prompt;
                } else {
                    stylePromptBox.value = '';
                }
            })
            .catch(error => {
                console.error('Error loading NPC style prompt:', error);
                stylePromptBox.value = '';
            });
        }

        function saveNpcStylePrompt() {
            const styleSelect = document.getElementById('npcStyleSelect');
            const stylePrompt = document.getElementById('npcStylePromptBox').value;
            
            if (!styleSelect.value) {
                alert('Please select a style to save.');
                return;
            }
            
            if (!stylePrompt.trim()) {
                alert('Style prompt cannot be empty.');
                return;
            }
            
            // Save to server using the same endpoint as monsters
            fetch('/toolkit/update_style_prompt', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    style_id: styleSelect.value,
                    prompt: stylePrompt
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Style prompt updated successfully!');
                } else {
                    alert('Failed to update style: ' + (data.error || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Error updating style:', error);
                alert('Failed to update style prompt');
            });
        }

        function saveAsNewNpcStyle() {
            const styleName = document.getElementById('newNpcStyleName').value;
            const stylePrompt = document.getElementById('npcStylePromptBox').value;
            
            if (!styleName.trim()) {
                alert('Please enter a name for the new style.');
                return;
            }
            
            if (!stylePrompt.trim()) {
                alert('Style prompt cannot be empty.');
                return;
            }
            
            // Save to server using the same endpoint as monsters
            fetch('/toolkit/save_new_style', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: styleName,
                    prompt: stylePrompt
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('New style saved successfully!');
                    
                    // Add to both dropdowns
                    const styleSelect = document.getElementById('npcStyleSelect');
                    const option = document.createElement('option');
                    option.value = data.style_id || styleName;
                    option.textContent = styleName + ' (Custom)';
                    styleSelect.appendChild(option);
                    styleSelect.value = data.style_id || styleName;
                    
                    // Also add to monster dropdown
                    const monsterStyleSelect = document.getElementById('genStyle');
                    if (monsterStyleSelect) {
                        const monsterOption = document.createElement('option');
                        monsterOption.value = data.style_id || styleName;
                        monsterOption.textContent = styleName + ' (Custom)';
                        monsterStyleSelect.appendChild(monsterOption);
                    }
                    
                    // Clear the new style name input
                    document.getElementById('newNpcStyleName').value = '';
                } else {
                    alert('Failed to save style: ' + (data.error || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Error saving new style:', error);
                alert('Failed to save new style');
            });
        }

        async function startNpcGeneration() {
            const selectedNpcs = document.querySelectorAll('input[name="npc-select"]:checked');
            const packName = document.getElementById('npcPackSelect').value;
            const moduleName = document.getElementById('npcModuleSelect').value;
            const model = document.getElementById('npcModelSelect').value;
            const styleSelect = document.getElementById('npcStyleSelect');
            const stylePrompt = document.getElementById('npcStylePromptBox').value;
            
            if (selectedNpcs.length === 0) {
                alert('Please select at least one NPC to generate.');
                return;
            }
            
            if (!packName || !moduleName) {
                alert('Please select both a module and target pack.');
                return;
            }
            
            if (!styleSelect.value || !stylePrompt) {
                alert('Please select a style template.');
                return;
            }
            
            const npcsToGenerate = Array.from(selectedNpcs).map(input => ({
                name: input.value,
                id: input.dataset.npcId
            }));
            
            // Show confirmation popup with generation settings
            const confirmationDiv = document.createElement('div');
            confirmationDiv.id = 'npc-confirmation-popup';
            confirmationDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #2a2a2a;
                border: 2px solid #ff9800;
                border-radius: 8px;
                padding: 20px;
                z-index: 10000;
                box-shadow: 0 4px 20px rgba(0,0,0,0.5);
                min-width: 400px;
                color: white;
            `;
            
            confirmationDiv.innerHTML = `
                <h3 style="margin: 0 0 20px 0; color: #ff9800;">Confirm Portrait Generation</h3>
                <div style="margin-bottom: 15px;">
                    <strong>Source Module:</strong> <span style="color: #4CAF50;">${moduleName}</span>
                </div>
                <div style="margin-bottom: 15px;">
                    <strong>Target Pack:</strong> <span style="color: #4CAF50;">${packName}</span>
                </div>
                <div style="margin-bottom: 15px;">
                    <strong>Style Template:</strong> <span style="color: #4CAF50;">${styleSelect.options[styleSelect.selectedIndex].text}</span>
                </div>
                <div style="margin-bottom: 15px;">
                    <strong>AI Model:</strong> <span style="color: #4CAF50;">${model}</span>
                </div>
                <div style="margin-bottom: 20px;">
                    <strong>NPCs to Generate:</strong> <span style="color: #4CAF50;">${npcsToGenerate.length} portrait${npcsToGenerate.length > 1 ? 's' : ''}</span>
                    <div style="max-height: 150px; overflow-y: auto; margin-top: 10px; padding: 10px; background: #1a1a1a; border-radius: 4px;">
                        ${npcsToGenerate.map(npc => `<div style="margin: 2px 0;"> ${npc.name}</div>`).join('')}
                    </div>
                </div>
                <div style="text-align: center;">
                    <button onclick="proceedWithNpcGeneration()" style="padding: 8px 20px; margin-right: 10px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Proceed</button>
                    <button onclick="cancelNpcGeneration()" style="padding: 8px 20px; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
                </div>
            `;
            
            document.body.appendChild(confirmationDiv);
            
            // Store settings for the 'proceed' function to use
            window.npcGenerationSettings = {
                moduleName,
                packName,
                model,
                style: styleSelect.value,
                stylePrompt,
                npcs: npcsToGenerate
            };
        }
        
        // Function to cancel NPC generation
        function cancelNpcGeneration() {
            const popup = document.getElementById('npc-confirmation-popup');
            if (popup) popup.remove();
            // Clear the stored settings
            delete window.npcGenerationSettings;
        }
        
        // Function to proceed with NPC generation after confirmation
        async function proceedWithNpcGeneration() {
            if (!window.npcGenerationSettings) return;
            
            // Retrieve the stored settings
            const { moduleName, packName, model, style, stylePrompt, npcs } = window.npcGenerationSettings;
            
            // Close the pop-up
            cancelNpcGeneration();
            
            // Show progress in NPC generation log
            addLog('npcGenLog', `Starting portrait generation for ${npcs.length} NPCs with ${style} style...`, 'info');
            
            // Show NPC progress bar
            document.getElementById('npcGenProgress').style.display = 'block';
            document.getElementById('npcGenProgressFill').style.width = '0%';
            document.getElementById('npcGenProgressFill').textContent = '0%';
            document.getElementById('npcGenStatus').textContent = 'Initializing portrait generation...';
            
            try {
                const response = await fetch('/api/toolkit/npcs/generate-portraits', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        module_name: moduleName,
                        pack_name: packName,
                        model: model,
                        style: style,
                        style_prompt: stylePrompt,
                        npcs: npcs
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    addLog('npcGenLog', 'Portrait generation started successfully!', 'success');
                } else {
                    addLog('npcGenLog', `Error starting generation: ${result.error}`, 'error');
                    document.getElementById('npcGenProgress').style.display = 'none';
                }
            } catch (error) {
                addLog('npcGenLog', `Failed to start generation: ${error}`, 'error');
                document.getElementById('npcGenProgress').style.display = 'none';
            }
        }

        // Export NPCs to Pack functionality
        function exportNpcsToPack() {
            const selectedNpcs = document.querySelectorAll('input[name="npc-select"]:checked');
            const packName = document.getElementById('npcPackSelect').value;

            if (selectedNpcs.length === 0) {
                alert('Please select one or more NPCs to export.');
                return;
            }
            if (!packName) {
                alert('Please select a destination pack.');
                return;
            }

            const npcIdsToExport = Array.from(selectedNpcs).map(cb => cb.dataset.npcId);
            
            const message = `You are about to copy the portraits for ${npcIdsToExport.length} NPC(s) into the '${packName}' graphic pack.\n\nThis is useful for creating a distributable pack for a module. Any existing portraits in the destination pack with the same name will be overwritten.\n\nProceed?`;

            if (confirm(message)) {
                performNpcExport(packName, npcIdsToExport);
            }
        }

        async function performNpcExport(packName, npcIds) {
            addLog('genLog', `Exporting ${npcIds.length} NPC portraits to pack '${packName}'...`, 'info');
            try {
                const response = await fetch('/api/toolkit/npcs/export-to-pack', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        pack_name: packName,
                        npc_ids: npcIds
                    })
                });
                const result = await response.json();

                if (result.success) {
                    addLog('genLog', `Successfully exported ${result.exported_count} portraits. Skipped ${result.skipped_count}.`, 'success');
                    // Refresh the view to show the updated status
                    loadNpcsForModule();
                } else {
                    addLog('genLog', `Export failed: ${result.error}`, 'error');
                    alert(`Export failed: ${result.error}`);
                }
            } catch (error) {
                addLog('genLog', `An error occurred during export: ${error}`, 'error');
                alert('An error occurred during the export process.');
            }
        }

        // === MODULE BUILDER SCRIPT ===

        // DOM Elements for Module Builder - Initialize as null, will be set after DOM loads
        let moduleForm = null;
        let generateBtn = null;
        let cancelBtn = null;
        let newModuleBtn = null;
        let progressSection = null;
        let resultsSection = null;
        let errorSection = null;
        let errorMessage = null;
        let statusMessage = null;
        let progressBar = null;
        let progressPercentage = null;
        let progressStages = null;
        let modulesListContainer = null;
        
        // Initialize module builder elements after DOM is ready
        function initializeModuleBuilderElements() {
            moduleForm = document.getElementById('module-form');
            generateBtn = document.getElementById('generate-btn');
            cancelBtn = document.getElementById('cancel-btn');
            newModuleBtn = document.getElementById('new-module-btn');
            progressSection = document.getElementById('generation-progress');
            resultsSection = document.getElementById('results-section');
            errorSection = document.getElementById('error-section');
            errorMessage = document.getElementById('error-message');
            statusMessage = document.getElementById('status-message');
            progressBar = document.getElementById('progress-bar');
            progressPercentage = document.getElementById('progress-percentage');
            progressStages = document.querySelectorAll('#progress-stages li');
            modulesListContainer = document.getElementById('modules-list');
        }
        
        // Set up module builder event listeners
        function setupModuleBuilderEventListeners() {
            // Form submission
            if (moduleForm) {
                moduleForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    
                    const moduleName = document.getElementById('module-name').value.trim();
                    const numAreas = parseInt(document.getElementById('num-areas').value);
                    const locationsPerArea = parseInt(document.getElementById('locations-per-area').value);
                    const narrative = document.getElementById('ai-narrative').value.trim();
                    
                    if (!moduleName || !narrative) {
                        showError('Please provide both module name and narrative');
                        return;
                    }
                    
                    socket.emit('start_build', {
                        module_name: moduleName,
                        num_areas: numAreas,
                        locations_per_area: locationsPerArea,
                        narrative: narrative
                    });
                    
                    moduleForm.style.display = 'none';
                    progressSection.style.display = 'block';
                    errorSection.style.display = 'none';
                    resultsSection.style.display = 'none';
                });
            }

            if (cancelBtn) {
                cancelBtn.addEventListener('click', () => {
                    if (confirm('Are you sure you want to cancel the module generation?')) {
                        socket.emit('cancel_build');
                    }
                });
            }

            if (newModuleBtn) {
                newModuleBtn.addEventListener('click', () => {
                    resetBuilderUI();
                });
            }
        }

        // Socket event handlers for builder
        socket.on('module_list_response', (modules) => {
            console.log('Received module list for builder:', modules);
            if (!modulesListContainer) {
                console.error('modulesListContainer is not initialized!');
                // Try to get it again
                modulesListContainer = document.getElementById('modules-list');
                if (!modulesListContainer) {
                    console.error('Could not find modules-list element!');
                    return;
                }
            }
            
            modulesListContainer.innerHTML = ''; // Clear the "Loading..." message

            if (!modules || modules.length === 0) {
                modulesListContainer.innerHTML = '<div class="no-modules">No modules found.</div>';
                return;
            }

            // Filter out system directories that might have been picked up
            const validModules = modules.filter(module => 
                !['campaign_archives', 'campaign_summaries', 'backups', 'conversation_history', 
                  'default', 'encounters', 'logs'].includes(module.moduleName)
            );

            if (validModules.length === 0) {
                modulesListContainer.innerHTML = '<div class="no-modules">No adventure modules found.</div>';
                return;
            }

            validModules.forEach(module => {
                const moduleItem = document.createElement('div');
                moduleItem.className = 'module-item';
                const levelRange = module.levelRange || { min: '?', max: '?' };
                
                moduleItem.innerHTML = `
                    <div class="module-name">${module.moduleName.replace(/_/g, ' ')}</div>
                    <div class="module-level">Levels ${levelRange.min} - ${levelRange.max}</div>
                    <div class="module-details">
                        <div class="module-detail-item"><span>Areas:</span><span>${module.areaCount || 'N/A'}</span></div>
                        <div class="module-detail-item"><span>Locations:</span><span>${module.locationCount || 'N/A'}</span></div>
                        <div class="module-detail-item"><span>Plot Points:</span><span>${module.plotPointCount || 'N/A'}</span></div>
                    </div>
                `;
                modulesListContainer.appendChild(moduleItem);
            });
        });

        socket.on('build_started', (data) => {
            if (statusMessage) statusMessage.textContent = data.message;
        });
        
        socket.on('module_progress', (data) => {
            const percentage = Math.round(data.percentage || 0);
            if (progressBar) progressBar.style.width = percentage + '%';
            if (progressPercentage) progressPercentage.textContent = percentage + '%';
            
            progressStages.forEach((stage, index) => {
                stage.classList.remove('stage-active', 'stage-complete');
                if (index < data.stage) {
                    stage.classList.add('stage-complete');
                } else if (index === data.stage) {
                    stage.classList.add('stage-active');
                }
            });
            
            if (statusMessage) statusMessage.textContent = data.message || `Processing: ${data.stage_name}`;
        });
        
        socket.on('module_complete', (data) => {
            if (progressSection) progressSection.style.display = 'none';
            if (resultsSection) resultsSection.style.display = 'block';
            const output = `Module Name: ${data.module_name}\n\n${data.message}\n\nThe module has been created successfully and is ready to use!`;
            const moduleOutput = document.getElementById('module-output');
            if (moduleOutput) moduleOutput.textContent = output;
            socket.emit('request_module_list');
        });
        
        socket.on('module_error', (data) => {
            showError(data.error);
            if (progressSection) progressSection.style.display = 'none';
        });
        
        socket.on('build_cancelled', (data) => {
            if (statusMessage) statusMessage.textContent = data.message;
            setTimeout(() => {
                resetBuilderUI();
            }, 2000);
        });
        
        function showError(message) {
            if (errorSection) {
                errorSection.style.display = 'block';
                if (errorMessage) errorMessage.textContent = message;
            }
        }
        
        function resetBuilderUI() {
            if(moduleForm) {
                moduleForm.style.display = 'block';
                if (progressSection) progressSection.style.display = 'none';
                if (resultsSection) resultsSection.style.display = 'none';
                if (errorSection) errorSection.style.display = 'none';
                if (progressBar) progressBar.style.width = '0%';
                if (progressPercentage) progressPercentage.textContent = '0%';
                progressStages.forEach(stage => stage.classList.remove('stage-active', 'stage-complete'));
                moduleForm.reset();
            }
        }
    </script>

    <!-- Media Popup Modal -->
    <div class="modal" id="media-modal">
        <div class="media-modal-content">
            <div class="media-modal-header">
                <h3 id="media-modal-title">Monster Preview</h3>
                <span class="media-modal-close" onclick="closeMediaPopup()">&times;</span>
            </div>
            <div class="media-modal-body" id="media-modal-body">
                <!-- Image or Video will be loaded here by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Pack Activation Confirmation Modal -->
    <div id="pack-confirm-modal" class="modal" style="display: none;">
        <div class="modal-content pack-confirm-content">
            <h3>Confirm Pack Activation</h3>
            <div class="modal-warning">
                <p><strong>Warning:</strong> Activating this pack will completely replace your current monster graphics.</p>
                <p>A backup of your current pack will be created with the following name:</p>
                <p class="backup-name" id="backup-name-preview"></p>
                <p>The backup will be saved in the graphic_packs folder and will appear in your Available Asset Packs list.</p>
            </div>
            <div class="modal-pack-info">
                <p>Activating pack: <strong id="activating-pack-name"></strong></p>
                <p>Current active pack: <strong id="current-pack-name"></strong></p>
            </div>
            <div class="modal-buttons">
                <button class="btn btn-danger" onclick="confirmPackActivation()">Activate Pack</button>
                <button class="btn btn-secondary" onclick="cancelPackActivation()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Merge Pack Confirmation Modal -->
    <div id="merge-confirm-modal" class="modal" style="display: none;">
        <div class="modal-content pack-confirm-content">
            <h3>Confirm Pack Merge</h3>
            <div class="modal-warning">
                <p><strong>Warning:</strong> This will copy all assets from the source pack into the active pack.</p>
                <p>Any files with the same name in the active pack <strong>will be overwritten</strong> by the files from the source pack. This action cannot be undone.</p>
            </div>
            <div class="modal-pack-info">
                <p>Merging From (Source): <strong id="merge-source-pack"></strong></p>
                <p>Merging Into (Destination): <strong id="merge-dest-pack"></strong></p>
            </div>
            <div class="modal-buttons">
                <button class="btn btn-primary" onclick="confirmMerge()">Confirm Merge</button>
                <button class="btn btn-secondary" onclick="cancelMerge()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Export to Pack Modal -->
    <div id="export-to-pack-modal" class="modal" style="display: none;">
        <div class="modal-content pack-confirm-content" style="min-width: 500px;">
            <h3 style="color: #4CAF50;">Export Monsters to New Pack</h3>
            <div class="modal-pack-info">
                <p>You are about to export <strong id="export-monster-count">0</strong> selected monster(s) to a new pack.</p>
            </div>
            
            <div style="margin: 20px 0;">
                <div class="form-group">
                    <label for="export-pack-name">Pack Name (Internal ID)</label>
                    <input type="text" id="export-pack-name" placeholder="e.g., shadows_of_kharos_pack" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white;">
                    <small style="color: #999;">Use lowercase letters, numbers, and underscores only</small>
                </div>
                
                <div class="form-group" style="margin-top: 15px;">
                    <label for="export-pack-display-name">Display Name</label>
                    <input type="text" id="export-pack-display-name" placeholder="e.g., Shadows of Kharos Monster Pack" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white;">
                </div>
                
                <div class="form-group" style="margin-top: 15px;">
                    <label for="export-pack-author">Author</label>
                    <input type="text" id="export-pack-author" placeholder="Your name or alias" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white;">
                </div>
                
                <div class="form-group" style="margin-top: 15px;">
                    <label for="export-pack-description">Description</label>
                    <textarea id="export-pack-description" rows="3" placeholder="Describe this pack's content and purpose" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white; resize: vertical;"></textarea>
                </div>
                
                <div class="form-group" style="margin-top: 15px;">
                    <label for="export-pack-style">Style Template</label>
                    <input type="text" id="export-pack-style" placeholder="e.g., photorealistic, fantasy_art" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white;">
                </div>
            </div>
            
            <div class="modal-buttons">
                <button class="btn btn-success" onclick="confirmExportToPack()">Create Pack</button>
                <button class="btn btn-secondary" onclick="cancelExportToPack()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- NPC Description Status Box -->
    <div id="npc-description-status-box" class="status-popup" style="display: none;">
        <h4 id="npc-status-title">Fetching Descriptions...</h4>
        <p id="npc-status-message">Initializing process...</p>
        <button onclick="this.parentElement.style.display='none'">Close</button>
    </div>
</body>
</html>